<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>An Introduction to C# graphics</title>
		<description>Various coding examples in C# and libraries for the budding Graphics programmer</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>An Introduction to DirectX 11 3D programming using C#</title>
				<description>&lt;h1 id=&quot;direct3d---introduction&quot;&gt;Direct3D - Introduction&lt;/h1&gt;

&lt;p&gt;In our past examples, we’ve looked at Fixed Function Pipelines and a quick look at the OpenGLb shader pipeline. This time around, we’ll take a look at setting up and using DirectX 11.&lt;/p&gt;

&lt;p&gt;SharpDX is the underlying library that we’re using for DirectX, as C# doesn’t have a native binding/library for accessing lower level graphics libraries.&lt;/p&gt;

&lt;p&gt;DirectX isn’t just a graphics library; it has support for Audio, Direct2D, Input, Fonts,  video, etc. However all we’re looking at in this lesson is the graphics side of things.&lt;/p&gt;

&lt;p&gt;SharpDX doesn’t abstract out as much as OpenTK does, so we have a fair bit more setup to do in order to be able to just clear a screen. Let’s take it in steps:&lt;/p&gt;

&lt;h2 id=&quot;creating-the-rendering-context&quot;&gt;Creating the rendering context&lt;/h2&gt;

&lt;p&gt;SharpDX provides a &lt;code class=&quot;highlighter-rouge&quot;&gt;RenderForm&lt;/code&gt; class that handles all the basic windows setup and management functionality.&lt;/p&gt;

&lt;p&gt;To initialize D3D, we begin by creating a D3D 11 Device and a D3D Device context. These two interfaces are our abstraction to the video card. So how do we do that?&lt;/p&gt;

&lt;p&gt;To create a D3D device, you need to define a swapchain. A swapchain defines:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The number of buffers used in page flipping.&lt;/li&gt;
  &lt;li&gt;How big the buffers should be.&lt;/li&gt;
  &lt;li&gt;The format of the backbuffer (color depth).&lt;/li&gt;
  &lt;li&gt;Refresh rate.&lt;/li&gt;
  &lt;li&gt;The handle to the window&lt;/li&gt;
  &lt;li&gt;Windowed/fullscreen&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Creating a swapchain looks like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mSwapChainDescription = new SwapChainDescription()
{
    BufferCount = 1,
    ModeDescription =
        new ModeDescription(
            mRenderForm.ClientSize.Width,
            mRenderForm.ClientSize.Height,
            new Rational(60, 1),
            Format.R8G8B8A8_UNorm),
    IsWindowed = true,
    OutputHandle = mRenderForm.Handle,
    SampleDescription = new SampleDescription(1, 0),
    Usage = Usage.RenderTargetOutput
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now that there is a definition of the swapchain, we need to build the D3D device. It’s pretty simple:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D3DDevice.CreateWithSwapChain(D3DDriverType.Hardware,
    DeviceCreationFlags.None,
    mSwapChainDescription,
    out mDevice,
    out mSwapChain);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For reference: &lt;a href=&quot;https://goo.gl/hIOU7z&quot;&gt;Creating the D3D Device&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Next up, we create a device context. From Microsoft:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A device context contains the circumstance or setting in which a device is used. More specifically, a device context is used to set pipeline state and generate rendering commands using the resources owned by a device. Direct3D 11 implements two types of device contexts, one for immediate rendering and the other for deferred rendering.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For this example, we’re going to be working with Immediate contexts.&lt;/p&gt;

&lt;p&gt;We also need buffers for the Backbuffer, front buffer, depth buffer. We build the buffers when we resize the window (or are in fullscreen mode and want to change resolutions).&lt;/p&gt;

&lt;p&gt;Each buffer has a specific way to be generated:&lt;/p&gt;

&lt;h3 id=&quot;backbuffer-is-acquired-from-the-swap-chain&quot;&gt;BackBuffer is acquired from the Swap Chain&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mBackBuffer = Texture2D.FromSwapChain&amp;lt;Texture2D&amp;gt;(mSwapChain, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;render-target-is-created-based-of-the-back-buffer&quot;&gt;Render Target is created based of the Back Buffer&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mRenderView = new RenderTargetView(mDevice, mBackBuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;the-depth-buffer&quot;&gt;The Depth buffer&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mDepthBuffer = new Texture2D(mDevice, new Texture2DDescription()
{
    Format = Format.D32_Float_S8X24_UInt,
    ArraySize = 1,
    MipLevels = 1,
    Width = mRenderForm.ClientSize.Width,
    Height = mRenderForm.ClientSize.Height,
    SampleDescription = new SampleDescription(1, 0),
    Usage = ResourceUsage.Default,
    BindFlags = BindFlags.DepthStencil,
    CpuAccessFlags = CpuAccessFlags.None,
    OptionFlags = ResourceOptionFlags.None
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;### The Depth Stencil View buffer&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mDepthView = new DepthStencilView(mDevice, mDepthBuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Why do they call it a Render Target and Depth Stencil ‘view’? Microsoft separates the concepts of resources (blocks of memory) and views. A view is just that, a ‘view’ into the data.&lt;/p&gt;

&lt;p&gt;Now that all the buffers/views have been created, we need to finalize the binding:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mDeviceContext.Rasterizer.SetViewport(
    new Viewport(0, 0,
        mRenderForm.ClientSize.Width,
        mRenderForm.ClientSize.Height,
        0.0f, 1.0f));
mDeviceContext.OutputMerger.SetTargets(mDepthView, mRenderView);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;loading-shaders&quot;&gt;Loading Shaders&lt;/h2&gt;

&lt;p&gt;Loading shaders in D3D is actually pretty easy:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mVertexShaderResult = ShaderBytecode.CompileFromFile(&quot;example01.fx&quot;, &quot;VS&quot;, &quot;vs_4_0&quot;);
mVertexShader = new VertexShader(mDevice, mVertexShaderResult);

mPixelShaderResult = ShaderBytecode.CompileFromFile(&quot;example01.fx&quot;, &quot;PS&quot;, &quot;ps_4_0&quot;);
mPixelShader = new PixelShader(mDevice, mPixelShaderResult);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The input and output of shaders are defined as part of a Shader ‘Signature’. We define that like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mSignature = ShaderSignature.GetInputSignature(mVertexShaderResult);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Defining the vertex layout is a little different than what we’ve seen in OpenGL:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mLayout = new InputLayout(
    mDevice,
    mSignature,
    new[]
    {
        new InputElement(&quot;POSITION&quot;, 0, Format.R32G32B32A32_Float, 0, 0),
        new InputElement(&quot;COLOR&quot;, 0, Format.R32G32B32A32_Float, 16, 0)
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the Shader file, this binds to the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct VS_IN
{
	float4 pos : POSITION;
	float4 col : COLOR;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can see how the two correlate to each other this way.&lt;/p&gt;

&lt;p&gt;Each &lt;code class=&quot;highlighter-rouge&quot;&gt;InputElement&lt;/code&gt; defines each element in the input layout - in this case, we’re defining the Position and Color, the format of each position and color are 4 floats. In order, the arguments are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The HLSL semantic associated with this element in a shader input-signature.&lt;/li&gt;
  &lt;li&gt;The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic name matrix, however each of the four component would have different semantic indices (0, 1, 2, and 3).&lt;/li&gt;
  &lt;li&gt;The data type of the element data.&lt;/li&gt;
  &lt;li&gt;Offset (in bytes) between each element. Use AppendAligned for convenience to define the current element directly after the previous one, including any packing if necessary.&lt;/li&gt;
  &lt;li&gt;An integer value that identifies the input-assembler. Valid values are between 0 and 15.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;definint-a-vertex-buffer&quot;&gt;Definint a Vertex Buffer&lt;/h2&gt;

&lt;p&gt;Again, pretty simple - Use &lt;code class=&quot;highlighter-rouge&quot;&gt;D3DBuffer&lt;/code&gt; to create the data:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mVertices = D3DBuffer.Create(
    mDevice,
    BindFlags.VertexBuffer,
    new[]
    {
      new Vector4(-1.0f, -1.0f, -1.0f, 1.0f), // Front Vertex
      new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // Front Color

      new Vector4(-1.0f,  1.0f, -1.0f, 1.0f), // Vertex
      new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // Color

      ...

      });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;and-a-constant-buffer&quot;&gt;And a constant buffer&lt;/h2&gt;

&lt;p&gt;We talked about constant buffers in the OpenGL shader tutorial, but to reiterate, a Shader Constant is input from the CPU to a shader. For example, a shader constant for the Model-View-Projection matrix is defined through a constant buffer.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mConstantBuffer = new D3DBuffer(
                    mDevice,
                    Utilities.SizeOf&amp;lt;Matrix&amp;gt;(),
                    ResourceUsage.Default,
                    BindFlags.ConstantBuffer,
                    CpuAccessFlags.None,
                    ResourceOptionFlags.None,
                    0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The size of the constant buffer, in this example, is defined by the size of a Matrix class - which is the Model-View-projection matrix.&lt;/p&gt;

&lt;p&gt;Also note, that in D3D, it’s more common to refer to it as a World-View-Projection matrix, rather than Model-View-Projection. For the rest of this document we will use that notation.&lt;/p&gt;

&lt;h2 id=&quot;prepping-for-rendering&quot;&gt;Prepping for Rendering&lt;/h2&gt;

&lt;p&gt;Time to set up the Device context for rendering:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set the input layout&lt;/li&gt;
  &lt;li&gt;Set the topology&lt;/li&gt;
  &lt;li&gt;Set the Vertex buffer binding (tell the VB what to draw)&lt;/li&gt;
  &lt;li&gt;Set the Constant buffer (the World-View-Projection Matrix) to the appropriate constant in the shader.&lt;/li&gt;
  &lt;li&gt;Set the Vertex and Pixel shaders&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mDeviceContext.InputAssembler.InputLayout = mLayout;
mDeviceContext.InputAssembler.PrimitiveTopology = PrimitiveTopology.TriangleList;
mDeviceContext.InputAssembler.SetVertexBuffers(
    0,
    new VertexBufferBinding(mVertices, Utilities.SizeOf&amp;lt;Vector4&amp;gt;() * 2, 0));
mDeviceContext.VertexShader.SetConstantBuffer(0, mConstantBuffer);
mDeviceContext.VertexShader.Set(mVertexShader);
mDeviceContext.PixelShader.Set(mPixelShader);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;finally-rendering-the-data&quot;&gt;Finally Rendering the data&lt;/h2&gt;

&lt;p&gt;Building matrices if fairly straightforward:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Matrix viewProj = Matrix.Multiply(mView, mProj);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Clearing buffers before rendering:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mDeviceContext.ClearDepthStencilView(
    mDepthView,
    DepthStencilClearFlags.Depth,
    1.0f,
    0);
mDeviceContext.ClearRenderTargetView(mRenderView, Color.Black);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Updating the constant buffer with data:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mDeviceContext.UpdateSubresource(ref worldViewProj, mConstantBuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And then to draw:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mDeviceContext.Draw(36, 0);&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;and-the-shader&quot;&gt;And the shader&lt;/h2&gt;

&lt;p&gt;Shader semantics are fairly similar between GLSL and HLSL. The differences really come down to syntax, more than anything else. For the Vertex Shader, we’ve already seen the format for the input data (the position and the color per vertex) defined. We also see a definition for the input for the Pixel Shader defined like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct PS_IN
{
	float4 pos : SV_POSITION;
	float4 col : COLOR;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And then there’s the constant in the shader file, defined for the World-View-Projection matrix:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;float4x4 worldViewProj;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now that we have the data defined, let’s see a vertex shader in action:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PS_IN VS( VS_IN input )
{
	PS_IN output = (PS_IN)0;

	output.pos = mul(input.pos, worldViewProj);
	output.col = input.col;

	return output;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Breaking it down line by line, we’re seeing the function signature for the Vertex shader defined as:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PS_IN&lt;/code&gt; is the output from the function (the definition is defined earlier), the name of the function, &lt;code class=&quot;highlighter-rouge&quot;&gt;VS&lt;/code&gt; and the input arguments into the Vertex Shader &lt;code class=&quot;highlighter-rouge&quot;&gt;VS_IN input&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the body of the function, we define the output of the function as the variable &lt;code class=&quot;highlighter-rouge&quot;&gt;output&lt;/code&gt; - which is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;PS_IN&lt;/code&gt;. and we initialize it all to 0.&lt;/p&gt;

&lt;p&gt;the next two lines populate both the position and color of the output.&lt;/p&gt;

&lt;p&gt;And, like all functions, we return a value, the &lt;code class=&quot;highlighter-rouge&quot;&gt;output&lt;/code&gt; variable.&lt;/p&gt;

&lt;p&gt;That’s the Vertex Shader. Now, looking at the Pixel shader, it should be fairly obvious what each is doing (to a point).&lt;/p&gt;

&lt;p&gt;The function &lt;code class=&quot;highlighter-rouge&quot;&gt;PS&lt;/code&gt; returns a &lt;code class=&quot;highlighter-rouge&quot;&gt;float4&lt;/code&gt; - that represents a color of the pixel that we’re trying to render. The input is the result out of the &lt;code class=&quot;highlighter-rouge&quot;&gt;VS&lt;/code&gt; function (ergo why it’s called &lt;code class=&quot;highlighter-rouge&quot;&gt;PS_IN&lt;/code&gt; - Pixel Shader INput).&lt;/p&gt;

&lt;p&gt;So, that only leaves the &lt;code class=&quot;highlighter-rouge&quot;&gt;: SV_Target&lt;/code&gt; bit on the pixel shader function definition.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SV_Target&lt;/code&gt; is a type of ‘System-Value’ semantics; it’s defined as part of the HSLS compiler. When used in a pixel shader, it describes the pixel location.&lt;/p&gt;

&lt;p&gt;To summarize, the vertex shader does nothing more than transform the vertex (and thus the triangle) into screen space and then interpolate the color passed in to the vertex shader across the triangle.&lt;/p&gt;

&lt;p&gt;HLSL shader sematics can be found &lt;a href=&quot;https://goo.gl/3N8AnL&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;building-a-better-library&quot;&gt;Building a better library&lt;/h1&gt;
&lt;p&gt;## The Shader Class&lt;br /&gt;
We want to simplify out coding process by creating several new classes that will allow us to more rapidly create applications. We’ll start out by building out a shader class to work with.&lt;/p&gt;

&lt;p&gt;We’ve created a new file, &lt;code class=&quot;highlighter-rouge&quot;&gt;Example02.cs&lt;/code&gt;. We still load the same shader file (shaders\example01.fx) but that is now loaded into a &lt;code class=&quot;highlighter-rouge&quot;&gt;Shader&lt;/code&gt; class: &lt;code class=&quot;highlighter-rouge&quot;&gt;mShader&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Shader&lt;/code&gt; is and IDisposable, so make sure you dispose of it correctly when you use it.  There’s a buch of things in there that we aren’t going to be talking about just yet, but patience, we will get to them!&lt;/p&gt;

&lt;p&gt;We have multiple &lt;code class=&quot;highlighter-rouge&quot;&gt;Load&lt;/code&gt; methods. One expecting an ‘fx’ file, and one that separates out the Pixel and Vertex shaders. I prefer to use separate files for shaders, but that is totally optional. So going forward with other programs, I’ll be using separate files.&lt;/p&gt;

&lt;p&gt;The process for using a Shader class is this - create the textual version of the shader (either as a hard-coded string or, as in this method, load the program off disk), compile the shader, set the parameters on the shader, and then call &lt;code class=&quot;highlighter-rouge&quot;&gt;Apply&lt;/code&gt; on the shader.&lt;/p&gt;

&lt;h2 id=&quot;the-cube-class&quot;&gt;The Cube class&lt;/h2&gt;
&lt;p&gt;I think we’re all tired of seeing the same code copied and pasted for the sample cube we use, so I’ve generated a &lt;code class=&quot;highlighter-rouge&quot;&gt;Cube&lt;/code&gt; class that encapsulates all this. Yes, it’s just a copy/paste of the code that handles all the relevant data and functionality of preparing a cube for rendering. But it will also be the inspiration for other classes later on.&lt;/p&gt;

&lt;h1 id=&quot;extending-the-cube-class&quot;&gt;Extending the Cube class&lt;/h1&gt;
&lt;p&gt;I expect that everyone is familiar with normals. Let’s extend the cube class to contain normals in it’s data. Looking at the class &lt;code class=&quot;highlighter-rouge&quot;&gt;CubeNormals&lt;/code&gt;, you can now see that we have vectors that contain the additional normal data.&lt;/p&gt;

&lt;p&gt;There’s no special reason why the vertex layout is in [position, normal, color] arrangement. We could easily have set up the orientation in any format we choose. We do, however, have to make sure that the &lt;em&gt;stride&lt;/em&gt; of the layout is set correctly. In this case, we’ve added one more &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector4&lt;/code&gt; into the mix, so our stride need to be updated appropriately. I think you can see that updating the stride manually like this is a pain. Once your data format is fairly concrete, you don’t have to worry as much about changing the format. However, it is highly possible that different meshes may have different data requirements (binormals, multiple UV and Color sets …) so you may want to take that into consideration with how you calculate your vertex stride.&lt;/p&gt;

&lt;p&gt;We also keep the Input Layout of the vertex data separate from the Cube structure. I’m currently torn on that - it arguably makes more sense to bind it elsewhere; since it uses the VertexShaderSignature, perhaps it should reside in the shader itself? I may change that in a later revision of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Shader&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;Looking at the method for setting the parameters on the shader, you now can see that we’re setting a few more data points - the last three, to be more specific. In this case, we’re looking at a light direction, an ambient color and a diffuse color. This example shows us how to properly set a Lighting ‘Constant buffer’ in D3D. Following into the &lt;code class=&quot;highlighter-rouge&quot;&gt;Shader&lt;/code&gt; class, you can see that we have a shader that contains a struct called &lt;code class=&quot;highlighter-rouge&quot;&gt;LightBuffer&lt;/code&gt;. It contains 2 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector4&lt;/code&gt; elements as well as a &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3&lt;/code&gt; element and a final &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; called &lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Why the &lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt; element? And why the &lt;code class=&quot;highlighter-rouge&quot;&gt;[StructLayout(Layoutkind.Sequential)]&lt;/code&gt; decorator? Hitting up the MSDN docs gives us a great hint as to why:&lt;br /&gt;
link: (https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.layoutkind(v=vs.110).aspx)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Controls the layout of an object when exported to unmanaged code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Aha. But no, not really. It actually it more related to the attribute &lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutKind.Sequential&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The members of the object are laid out sequentially, in the order in which they appear when exported to unmanaged memory. The members are laid out according to the packing specified in StructLayoutAttribute.Pack, and can be noncontiguous.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We don’t want noncontiguous when sending data to our GPU. OK, that’s all fine and dandy, but why the &lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Rules for packing constant buffers can be a little odd. Constant buffers are expected to align on a 16 byte boundary; the start of a variable in a constant buffer needs to be aligned on a 16 byte boundary. So we add a float into the mix to ensure that if we add another variable at the end of this struct, it comes after the padding and ensures that we’re properly aligned.&lt;/p&gt;

&lt;p&gt;The other way of solving this is to be more explicit in how we define our elements in the structure:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[StructLayout(LayoutKind.Explicit)]
public struct LightBuffer
{
    [FieldOffset(0)]
    public Vector4 ambientColor;

    [FieldOffset(16)]
    public Vector4 diffuseColor;

    [FieldOffset(32)]
    public Vector3 lightDirection;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Both have their pros and cons. I’ll leave it up to the reader to decide which is best for their needs.&lt;/p&gt;

&lt;p&gt;Now that we have the layout of the constant buffer, we need a &lt;code class=&quot;highlighter-rouge&quot;&gt;BufferDescription&lt;/code&gt; for that buffer:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BufferDescription lightBufferDesc = new BufferDescription()
{
    Usage = ResourceUsage.Dynamic,
    SizeInBytes = Utilities.SizeOf&amp;lt;LightBuffer&amp;gt;(),
    BindFlags = BindFlags.ConstantBuffer,
    CpuAccessFlags = CpuAccessFlags.Write,
    OptionFlags = ResourceOptionFlags.None,
    StructureByteStride = 0
};

mLightConstantBuffer = new D3DBuffer(device, lightBufferDesc);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and to put data into this buffer for the shader to use:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DataStream mappedResourceLight = default(DataStream);
device.ImmediateContext.MapSubresource(mLightConstantBuffer, MapMode.WriteDiscard, MapFlags.None, out mappedResourceLight);
mappedResourceLight.Write(lightBuffer);
device.ImmediateContext.UnmapSubresource(mLightConstantBuffer, 0);

device.ImmediateContext.PixelShader.SetConstantBuffer(0, mLightConstantBuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;texturing&quot;&gt;Texturing&lt;/h1&gt;
&lt;p&gt;Rendering stuff isn’t very useful if you can’t texture it. This next bit covers some fairly simple aspects of loading and using textures in D3D&lt;/p&gt;

&lt;p&gt;First thing first, let’s look at our new model class, &lt;code class=&quot;highlighter-rouge&quot;&gt;CubeTextureNormals&lt;/code&gt;. From it’s name, you can probably tell what it contains: positions, normals, and … textures?&lt;/p&gt;

&lt;p&gt;Well, not really, ‘textures’, but texture UV coordinates. Simply put, UV coordinate sets define where, in ‘texture space’ a vertex would fall on a texture. Texture space is defined between 0 and 1 and starts at the top left of a texture.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uv_coordinates.png&quot; alt=&quot;UV coordinates&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For our needs, we are only using 2D coordinates (yes, you can have 3D textures). Applying a triangle onto the texture can be visualized like so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/triangle_uv_coordinates.png&quot; alt=&quot;Triangle mapped to UV&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Points a, b and c would have coresponding UV values mappeed against the texture. Nothing crazy there. I’ve coded them by hand (you’re welcome) but you’d want to use a proper 3D DCC package to do it right. There are also various projections you could use to automatically generate the UV coordinates onto regular shapes, but that’s beyond the scope of this article.&lt;/p&gt;

&lt;p&gt;Now that you have UV data for your content, we need to load some textures to use!  To that end, I’ve created a &lt;code class=&quot;highlighter-rouge&quot;&gt;Texture&lt;/code&gt; class we can use. There’s really nothing surprising here. SharpDX has access to the ‘Windows Imaging Component’; a Microsoft API that gives us access to some fairly low level functionality for reading/writing image data. (link: https://msdn.microsoft.com/en-us/library/windows/desktop/ee719902.aspx). The big takeaway here is that WIC allows us to read pretty much any image data type.&lt;/p&gt;

&lt;p&gt;Note: as an exercise to the reader, there is an intentional bug here. Where is it? What does it do? How do you fix it?&lt;/p&gt;

&lt;p&gt;The takeaway from this class is that we want to provide to D3D a &lt;code class=&quot;highlighter-rouge&quot;&gt;ShaderResourceView&lt;/code&gt; that maps a &lt;code class=&quot;highlighter-rouge&quot;&gt;Texture2D&lt;/code&gt;. That resource is then fed into a ‘Sampler’ that can do many, many things to a texture. I won’t go over all the grubby details of that, aside from the fact that allows for interpolation between pixels of an image, or combination of pixels in an image, depending upon how close/far from a triangle the viewer is.&lt;/p&gt;

&lt;p&gt;You create a sampler using a &lt;code class=&quot;highlighter-rouge&quot;&gt;SamplerStateDescription&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;SamplerState&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;SamplerStateDescription&lt;/code&gt; is just that, a description object that says how to create the &lt;code class=&quot;highlighter-rouge&quot;&gt;SamplerState&lt;/code&gt;. From the MSDN, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SamplerState&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sampler state determines how texture data is sampled using texture addressing modes, filtering, and level of detail.  Sampling is done each time a texture pixel, or texel, is read from a texture. A texture contains an array of texels, or texture pixels. The position of each texel is denoted by (u,v), where u is the width and v is the height, and is mapped between 0 and 1 based on the texture width and height. The resulting texture coordinates are used to address a texel when sampling a texture.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;link: (https://msdn.microsoft.com/en-us/library/ff604998.aspx)&lt;/p&gt;

&lt;p&gt;I do want to go into much more detail on this, but Jay is looking to talk more about SamplerStates and different types of filtering. I’m going to park this topic here until he has a chance to talk about it.&lt;/p&gt;

&lt;p&gt;Just like everything else we’ve done, we need to let the D3D pipeline know what’s going on. We enable a sampler like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mDeviceContext.PixelShader.SetSampler(0, mSampler);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And we update the shader to now take a &lt;code class=&quot;highlighter-rouge&quot;&gt;ShaderViewResource&lt;/code&gt; that maps to our texture:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mShader.SetShaderParam(mDevice, new Vector3(0.0f, 5.0f, 5.0f), mTexture.TextureResource, new Vector4(1.0f, 1.0f, 1.0f, 1.0f), new Vector4(0.1f, 0.1f, 0.1f, 1.0f), ref world, ref viewProj);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And in the shader, we take that &lt;code class=&quot;highlighter-rouge&quot;&gt;ShaderResourceView&lt;/code&gt; and apply it to the pixel shader (the vertex shader doesn’t use it at all)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void SetShaderParam(D3DDevice device, Vector3 lightDirection, ShaderResourceView texture, Vector4 ambientColor, Vector4 diffuseColour, ref Matrix world, ref Matrix viewproj)
{
...
   device.ImmediateContext.PixelShader.SetShaderResource(0, texture);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;but-thats-not-all&quot;&gt;But that’s not all!&lt;/h2&gt;

&lt;p&gt;One other thing that we do in &lt;code class=&quot;highlighter-rouge&quot;&gt;Example04&lt;/code&gt; is break down the transformation matrices passed into the vertex shader. Previously we’ve been combining all the matrices into a world-view-projection matrix. However that may not be useful in the long run. When we have multiple objects, you may want to pre-computer the view-projection matrix, but the world matrix will change from object to objet (they all won’t be transformed into world space - the GPU is better at doing that).&lt;/p&gt;

&lt;p&gt;So, we have a &lt;code class=&quot;highlighter-rouge&quot;&gt;MatrixBuffer&lt;/code&gt;, laid out very similarly to the LightBuffer!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[StructLayout(LayoutKind.Sequential)]
internal struct MatrixBuffer
{
    public Matrix world;
    public Matrix viewproj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;No padding necesary here.&lt;/p&gt;

&lt;p&gt;Sending this across to the GPU is, again, fairly straightforward:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;device.ImmediateContext.MapSubresource(mMatrixConstantBuffer,
                                       MapMode.WriteDiscard,
                                       MapFlags.None,
                                       out mMappedResourceMatrix);
mMappedResourceMatrix.Write(matrixBuffer);
device.ImmediateContext.UnmapSubresource(mMatrixConstantBuffer, 0);

device.ImmediateContext.VertexShader.SetConstantBuffer(1, mMatrixConstantBuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;However, we do have to have a bit of glue code on the shader side of things. The definition of that buffer in the vertex shader looks like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cbuffer MatrixBuffer : register(b1)
{
    matrix world;
    matrix viewproj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;register(b1)&lt;/code&gt; tells the HLSL shader compiler what constant buffer register (or ‘slot’) to use for reading the data. In the C# side, that maps to the ‘1’ in&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;device.ImmediateContext.VertexShader.SetConstantBuffer(1, mMatrixConstantBuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The layout of the &lt;code class=&quot;highlighter-rouge&quot;&gt;register&lt;/code&gt; keyword can be found here: (https://msdn.microsoft.com/en-us/library/windows/desktop/dd607359(v=vs.85).aspx)&lt;/p&gt;

&lt;p&gt;Shader model reference link: (https://msdn.microsoft.com/en-us/library/windows/desktop/bb509638(v=vs.85).aspx)&lt;/p&gt;

&lt;h1 id=&quot;something-sort-of-resembling-a-framework-example05cs&quot;&gt;Something sort of resembling a framework (Example05.cs)&lt;/h1&gt;
&lt;p&gt;No, it’s not &lt;em&gt;really&lt;/em&gt; a framework now, but it’s starting to look more an more like one. Yes, it’s still another spinning cube, but the cube, this time, was generated in Maya, not by hand. Thus we now have a rudimentary &lt;code class=&quot;highlighter-rouge&quot;&gt;RenderMesh&lt;/code&gt; class that holds a renderable object.&lt;/p&gt;

&lt;p&gt;So, a &lt;code class=&quot;highlighter-rouge&quot;&gt;RenderableMesh&lt;/code&gt; has a D3DBuffer for vertex data, only reads Triangles (no index buffer at this point), and also contains a &lt;code class=&quot;highlighter-rouge&quot;&gt;RenderMaterial&lt;/code&gt; class instance.  For a lot of you, this is old hat, especially if you’ve worked in any 3D DCC, but a Material in this case defines color information that should be applied to a mesh. Typically that includes an ambient color, specular, diffuse … textures … it really depends on your shading model.  For this case, tho, we’re going to use a fairly simple shading model; ambient color, diffuse color and a diffuse map.  In a later example, we’re going to do much, much more complex shaders.&lt;/p&gt;

&lt;p&gt;However, we need to be able to load data from an intermediate file format. In this case, .fbx (although other formats are supported). Are we going to write our own import library? Hell no. There’s a fantastics Open Source library out there for both C++ and C# called Open Asset Import library: (https://github.com/assimp)&lt;/p&gt;

&lt;p&gt;Yes, it’s called AssImp. Shut up.&lt;/p&gt;

&lt;p&gt;What I’ve done is created a static class called &lt;code class=&quot;highlighter-rouge&quot;&gt;MeshManager&lt;/code&gt; that tracks loaded meshes (so you don’t re-load an existing mesh) and provides a &lt;code class=&quot;highlighter-rouge&quot;&gt;RenderMesh&lt;/code&gt; for you. It uses the AssImp library to do all the heavy lifting. What we do with that library is access all the vertex and material data and generate the &lt;code class=&quot;highlighter-rouge&quot;&gt;RenderMesh&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;RenderMaterial&lt;/code&gt; from it. There are a few convenience functions in there (building a proper path to the assets, including textures), as well as some data validation.&lt;/p&gt;

&lt;p&gt;But there is a lot more it can (and will) do. Loading an asset from an fbx, dae or other file format is not a quick process. It’s fairly complex. Also, intermediate file formats are &lt;em&gt;large&lt;/em&gt;. They don’t have to be. Especially considering what we want as data. So the actual goal of this tool class will be to eventually generate a ‘transform’ of an intermediate data file into a highly compact and potentially streamable version of the data, in binary form.  But more on that later (much later).&lt;/p&gt;

&lt;p&gt;To that end, I’ve also updated the Shader as well - the constant buffer for the &lt;code class=&quot;highlighter-rouge&quot;&gt;LightBuffer&lt;/code&gt; hasn’t changed, but we’ve broken the &lt;code class=&quot;highlighter-rouge&quot;&gt;MatrixBuffer&lt;/code&gt; down even further to contain the workd, view and projection matrices. This is far from optimal, but there’s a reason for this madness.&lt;/p&gt;

&lt;p&gt;See, as I was building &lt;code class=&quot;highlighter-rouge&quot;&gt;Example05&lt;/code&gt;, I was having a heck of a time getting the object transformation &lt;em&gt;just&lt;/em&gt; right. So I broke the matrices down into their individual components so I could better debug them - make sure that what I was sending in was what I was expecting.&lt;/p&gt;

&lt;p&gt;“But wait!” you say, with baited breath. “It’s a shader. How can you debug shaders! In C#!”.&lt;/p&gt;

&lt;p&gt;Well, you don’t debug them. In C#. You debug them in the graphics debugger. And in Windows 10. if you’re on Windows 7, you may be SOL.&lt;/p&gt;

&lt;p&gt;If you’re in dev studio and start up the ‘Graphics Debugger’, you’re in for some win!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_01.png&quot; alt=&quot;Graphics Debugging&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And that starts up the graphics debugger! (BTW - totally available in the community edition of VS!)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_02.png&quot; alt=&quot;graphic_debugging_02.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Grabbing a sample of what’s going on? Press the ‘Capture Frame’ button:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_03.png&quot; alt=&quot;graphic_debugging_03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once you’ve snagged some frames, you can now start debugging what’s going on. There’s a lot in here, and I won’t cover it all here. But I’ll hit the highlights.&lt;/p&gt;

&lt;p&gt;Let’s inspect a captured frame:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_04.png&quot; alt=&quot;graphic_debugging_04.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That opens up a whole other debugger!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_05.png&quot; alt=&quot;graphic_debugging_05.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the ‘Event List’ window, you can see all the D3D calls that have been invoked.  Expand the ‘Draw’ item in it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_06.png&quot; alt=&quot;graphic_debugging_06.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and then click on, say, the Input Layout item:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_07.png&quot; alt=&quot;graphic_debugging_07.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The arrows pointing to the two buttons? Those are the vertex and pixel shader debuggers. When you click on them, they simulate what happens in the appropriate shader. Go ahead and click on the vertex shader ‘play’ button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_08.png&quot; alt=&quot;graphic_debugging_08.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That is an honest to god debugger for your vertex and pixel shader. You can set breakpoints, inspect variables. You can’t change values to see what happens, but it is a great way to figure out what’s where and what values are being processed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_09.png&quot; alt=&quot;graphic_debugging_09.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can also inspect and see what are in constant buffers&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_10.png&quot; alt=&quot;graphic_debugging_10.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_11.png&quot; alt=&quot;graphic_debugging_11.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/graphic_debugging_12.png&quot; alt=&quot;graphic_debugging_12.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, as you can see, we’ve actually got some decent debugging tools with D3D and Visual Studio, out of the box. We’ll explore these tools more as we progress along our merry little way.&lt;/p&gt;

&lt;h2 id=&quot;a-couple-of-notes&quot;&gt;A couple of notes&lt;/h2&gt;
&lt;p&gt;The shaders that we use here are fairly lightweight.  They’re also unoptimized.&lt;/p&gt;

&lt;p&gt;I don’t mean, I haven’t witten them optimally (I haven’t, but that’s because I’m being purposely verbose). I’ve disabled compiliation optimizations on the shaders so that the above debugger has better data for being able to debug them.&lt;/p&gt;

&lt;p&gt;I’ve done this in the shader compiler:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public bool Load(D3DDevice device, string vsData, string psData)
{
    if (device == null || vsData == string.Empty || psData == string.Empty)
    {
        return false;
    }

    mVertexShaderResult = ShaderBytecode.Compile(vsData, &quot;VS&quot;, VertexShaderVersion, ShaderFlags.Debug | ShaderFlags.SkipOptimization);
    mPixelShaderResult = ShaderBytecode.Compile(psData, &quot;PS&quot;, PixelShaderVersion, ShaderFlags.Debug | ShaderFlags.SkipOptimization);

    return (mVertexShaderResult.ResultCode == Result.Ok) &amp;amp;&amp;amp;
            (mPixelShaderResult.ResultCode == Result.Ok);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Specifically, using the following flags:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ShaderFlags.Debug | ShaderFlags.SkipOptimization&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In production code, you’ll want to remove them or replace them with something more appropriate.&lt;/p&gt;

&lt;h1 id=&quot;and-a-camera-to-round-out-this-mess&quot;&gt;And a camera to round out this mess&lt;/h1&gt;
&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;Example06&lt;/code&gt; I finally introduce a camera class into the mix. It encapsulated the View and Projection matrices, exposes accessors for them and updates the camera based on input.&lt;/p&gt;

&lt;p&gt;I’m cheating a fair bit here and using OpenTK’s input library to get the caemra up and running. I will eventually move away from this and use DirectInput (or whatever D3D 11 is calling it these days).  This camera is essentially a near-verbatim copyu of the previous OpenGL camera I created, replacing all the matrix operations with the comparable D3D calls.&lt;/p&gt;

&lt;p&gt;Also note that I’m using a Left Handed co-ordinate system. Who says you need to use a Right Handed co-ordinate system!&lt;/p&gt;

&lt;p&gt;#Summary&lt;br /&gt;
That’s pretty much it for an intro. We’ll dig further into D3D in a future lesson, exploring lighting models and different material systems.  And with that, I’m out!&lt;br /&gt;
## Additional links&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gl/5kHKFz&quot;&gt;DirectX 11 Website&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sat, 11 Mar 2017 00:00:00 -0800</pubDate>
				<link>http://localhost:4000/2017/03/D3DIntroduction</link>
				<guid isPermaLink="true">http://localhost:4000/2017/03/D3DIntroduction</guid>
			</item>
		
			<item>
				<title>An Introduction to OpenGL and the Shader Language</title>
				<description>&lt;h1 id=&quot;opengl---an-introduction-to-a-more-modern-approach&quot;&gt;OpenGL - An introduction to a more modern approach&lt;/h1&gt;

&lt;p&gt;In the previous section, we discussed the legacy OpenGL programming model (more commonly refered to as the ‘Fixed Function Pipeline’). In this next section, we’re going to investigate a more modern approach, that utilizes shaders, Vertex buffers, Index buffers and how to send data to shaders from your program.&lt;/p&gt;

&lt;h2 id=&quot;to-start---a-more-proper-framework&quot;&gt;To start - a more proper framework&lt;/h2&gt;

&lt;p&gt;In the Introduction project, a lot of things were put together hapdash. I’ve corrected that in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ShaderIntroduction&lt;/code&gt; project:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/InitialClassLayout.png&quot; alt=&quot;Initial Class Layout&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A fair bit has changed with this codebase. I’ve been a bit more regimented in how these classes were defined. They’re also a bit more generalized and properly reusable. Some things to note:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ExampleBase&lt;/code&gt; class Contains a &lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt; by default. It is never Updated (I may change this) so it is up to the derived class to update the camera.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt; class is a fairly rough FPS-style camera. I will be cleaning this up as we go. However, the &lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt; class also maintains the Projection matrix, as well as the View matrix. Traditionally, cameras maintain that information.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TextureManager&lt;/code&gt; is extracted into it’s own class. This will not be used in this lesson (currently), but is going to be used in later lessons.&lt;/li&gt;
  &lt;li&gt;The same goes for the &lt;code class=&quot;highlighter-rouge&quot;&gt;RenderGrid&lt;/code&gt; class.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In our previous codebase, we were using a more ‘legacy’ based version of OpenGL; this is the fixed function version of OpenGL that does not support shaders.  In this example, we’re going to start talking about using proper shaders. We’re not going to touch on Texturing in this introduction. What we are going to cover, however consists of:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Vertex and Index buffers.&lt;/li&gt;
  &lt;li&gt;Setting up data.&lt;/li&gt;
  &lt;li&gt;Setting up and creating simple shaders.&lt;/li&gt;
  &lt;li&gt;Sending data to shaders.&lt;/li&gt;
  &lt;li&gt;Rendering.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is a surprising amount of material to cover and our once-simple applications from the first lesson are going to become significantly more complex.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-vertex-buffer&quot;&gt;What is a Vertex buffer?&lt;/h2&gt;

&lt;p&gt;In our Legacy pipeline (from lesson01), we defined geometry data through using a set of OpenGL state calls to&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    GL.Begin(primitve)
       GL.Color()
       GL.VertexN()
    GL.End()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This if far from optimal, considering that for a large amount of data, it never changes. So we can defien a ‘buffer’ of data - in this case a buffer of Vertex data. That goes into what OpenGL calls a &lt;code class=&quot;highlighter-rouge&quot;&gt;Vertex Buffer Object&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;VBO&lt;/code&gt;.  Wikipedia defines a VBO as&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Vertex Buffer Object (VBO) is an OpenGL feature that provides methods for uploading vertex data (position, normal vector, color, etc.) to the video device for non-immediate-mode rendering. VBOs offer substantial performance gains over immediate mode rendering primarily because the data resides in the video device memory rather than the system memory and so it can be rendered directly by the video device. These are equivalent to vertex buffers in Direct3D.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However, in modern OpenGL, it is just a &lt;em&gt;buffer&lt;/em&gt; of data. It has no inherent structure as far as OpenGL is concerned; you can put whatever the heck you want into it. It is up to a shader program to evaluate the contents of that buffer.&lt;/p&gt;

&lt;p&gt;If there is no inherent structure to the data, then how does it work? Let’s walk through a simple example (which is what we use in the current codebase). Let’s assume that right now the only data we want to work with is triangle data. A triangle consists of three vertices: X, Y and Z. We also want to colourized the triangle, so each vertex will have a color component (R, G, B, A). So for each vertex element, we are going to have something that looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/VBOIntrospection01.png&quot; alt=&quot;VBO layout&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What we’re saying here is that we’re using 12 bytes (3 floats @ 4 bytes/float) to define the positional data of a vertex and 16 bytes (4 floats @ 4 bytes/float) for the color component. This results in a total of 28 bytes for the total data per vertex. This is called the &lt;code class=&quot;highlighter-rouge&quot;&gt;Stride&lt;/code&gt; of the vertex data. What we have done here is created an &lt;code class=&quot;highlighter-rouge&quot;&gt;interleaved&lt;/code&gt; data format. We end up with data that looks like this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[V][C][V][C][V][C][V][C] …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The stride defines how far we have to jump to get to the next block of data (eg: once we’ve read the first vertex, to get at the next vertex, we have to jump N bytes to read the next vertex … if we skip the color data).&lt;/p&gt;

&lt;p&gt;We can also store the vertex attribute data in ‘blocks’, and thus not interleaving the data. Like so:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[VVVV…][CCC…]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Using an interleaved format is probably the most performant, but there are always exceptions to the rule.  So why is it the most performant overall?  From Wikipedia:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Interleaved data formats cause less GPU cache pressure, because the vertex coordinate and attributes of a single vertex aren’t scattered all over in memory. They fit consecutively into few cache lines, whereas scattered attributes could cause more cache updates and therefore evictions. The worst case scenario could be one (attribute) element per cache line at a time because of distant memory locations, while vertices get pulled in a non-deterministic/non-contiguous manner, where possibly no prediction and prefetching kicks in. GPUs are very similar to CPUs in this matter.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It’s also not just VBOs that you’re interested in. You will also want to create an Index Buffer (OpenGL calls these Element Buffer Object or EBOs).  So, what is an EBO? What do we need these for?  Let’s do a simple example to illustrate:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/EBOIntrospection01.png&quot; alt=&quot;EBO layout&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, what we’ve done is essentially reduce the amount of data that we need to represent a mesh.  If we store the data as pure triangles, with duplication, we end up with &lt;code class=&quot;highlighter-rouge&quot;&gt;2 Triangles x 3 vertices x 3 floats(x,y,z) x 4 bytes/vertex&lt;/code&gt; (no color information in this case) - 72 bytes (168 bytes if we include color). However, using an index buffer, we reduce that to &lt;code class=&quot;highlighter-rouge&quot;&gt;4 vertices x 3 floats x 4 bytes/vertex&lt;/code&gt; - 48 bytes. Adding the index buffer into the mix is &lt;code class=&quot;highlighter-rouge&quot;&gt;6 indices x 4 bytes&lt;/code&gt; - 24 bytes. But that’s assuming 4 bytes/index. Which we really, REALLY don’t need to use. Remember, a &lt;code class=&quot;highlighter-rouge&quot;&gt;uint&lt;/code&gt; gives us a grand total of 4,294,967,295 / 3 (1,431,655,765 triangles). I fear the day we need almost 1.5 billion triangles for games. So we could use half that (a &lt;code class=&quot;highlighter-rouge&quot;&gt;ushort&lt;/code&gt; for instance) to get 65,000 triangles.&lt;/p&gt;

&lt;p&gt;However, just in case you think it isn’t that much of a saving. Let’s assume you have a 50,000 triangle mesh. And you have the standard 28 byes/vertex.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    50000 x 3 x 28 = 4,200,000 bytes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It’s really hard to say what kind of loss we’d get because it really depends on the mesh geometry, but let’s assume a fully connected mesh where each triangle adds only one additional vertex.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   ( 50000 + 3 ) * 28 = 1,400,084
   50000 * 3 indices * 2 bytes/index = 300,000
   Total: 1,700,084
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The less data we need to transfer, the better.  The math may be off, but you can see a couple of additional improvements here as well - we don’t have to duplicate vertices! Instead of an additional 3 floats to represent 1 vertex, we simply add 1 uint to point the an existing vertex in the VBO.&lt;/p&gt;

&lt;p&gt;How do you go about creating a &lt;code class=&quot;highlighter-rouge&quot;&gt;VBO&lt;/code&gt;? I’ve encapsulated the core functionality of a VBO in the &lt;code class=&quot;highlighter-rouge&quot;&gt;VertexBuffer&lt;/code&gt; class. The process can be broken down into the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Determine the layout of your vertex data. In this case, I’ve already done that.&lt;/li&gt;
  &lt;li&gt;Create a data store to transiently hold the data. This is the data your application will track. You’ll also promote this to OpenGL. In the case of our example, we create a &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; array that can hold all the data. If your data is not of a consistent data type (ie: you may use a mix of doubles, floats, even ints), you may want to use a struct array instead.&lt;/li&gt;
  &lt;li&gt;Create a data store for your EBO.&lt;/li&gt;
  &lt;li&gt;You’ll need to have OpenGL create a VBO and EBO buffer for you. Like all buffers in OpenGL, a buffer is represented by an integer value. That ID is written into &lt;code class=&quot;highlighter-rouge&quot;&gt;mVertexBufferObjectID&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Populate the VBO and EBO with data.&lt;/li&gt;
  &lt;li&gt;Do Render Stuff (Purposely left high level at this point).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;generating-vbos-and-ebos&quot;&gt;Generating VBOs and EBOs&lt;/h2&gt;

&lt;p&gt;First off, we need a place to store the data. in &lt;code class=&quot;highlighter-rouge&quot;&gt;VertexBuffer&lt;/code&gt;, we have two members:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    protected float[] mVertexData;
    protected uint[] mIndexData;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is just a way to temporarily hold the data until we can push it up to the graphics card. Populating this array is nothing fancy - check out &lt;code class=&quot;highlighter-rouge&quot;&gt;AddTriangle&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AddVertex&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;AddIndex&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, to create a VBO and EBO:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    GL.GenBuffers( numBuffersToGenerate, buffersGenerated)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But all that does is create a buffer. Now that we have a buffer, we can start working with the data. Remember, OpenGL still works like a state machine, even though it’s ‘Modern’ OpenGL. Now that we have a buffer ID (the Buffer ID is called a &lt;code class=&quot;highlighter-rouge&quot;&gt;buffer object name&lt;/code&gt;), we can start working with it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    GL.BindBuffer(bufferTargetType, bufferName)
    GL.BufferData(bufferTargetType, size, data, usage)
    GL.BindBuffer(bufferTargetType, bufferName)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;What do we have now? If done right, we have a buffer for Vertex data and a buffer for index data.&lt;/p&gt;

&lt;p&gt;How do we render this? That’s where shaders come in.&lt;/p&gt;

&lt;h2 id=&quot;vertex-shaders&quot;&gt;Vertex Shaders&lt;/h2&gt;

&lt;p&gt;I’m going to start off with the technical side of loading up a shader first. After that, more details on the shaders themselves and how we end up getting data into the shaders.&lt;/p&gt;

&lt;p&gt;First off, we need some way of creating shaders. Instead of hard-coding it, we’re going to load it from a text file. It’s part of the project, so it gets copied into the output folder.&lt;/p&gt;

&lt;p&gt;Loading the shaders is fairly straightforward, we use the &lt;code class=&quot;highlighter-rouge&quot;&gt;File.ReadAllText()&lt;/code&gt; function to pull in all the text from the shader.&lt;/p&gt;

&lt;p&gt;Now that we have the shader text, we need to compile the shader. Just like the VBOs and EBOs, we need to create a Shader Named object.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    VertexShaderID = GL.CreateShader(ShaderType.VertexShader);
    FragmentShaderID = GL.CreateShader(ShaderType.FragmentShader);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we have shader ID to work with. It’s time to compile the shader:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   GL.ShaderSource(VertexShaderID, VertexShaderSource);
   GL.CompileShader(VertexShaderID);
   GL.GetShaderInfoLog(VertexShaderID, out info);
   GL.GetShader(VertexShaderID, ShaderParameter.CompileStatus, out statusCode);

   if (statusCode != 1)
   {
      Console.Write(info);
      throw new ApplicationException(info);
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We have to compile two shaders, one for the vertex shader and one for the fragment shader. The shaders, working together constitutes a &lt;code class=&quot;highlighter-rouge&quot;&gt;Program&lt;/code&gt;. So we need to create a program and attach shaders to it:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Program = GL.CreateProgram();
    GL.AttachShader(Program, FragmentShaderID);
    GL.AttachShader(Program, VertexShaderID);

    GL.LinkProgram(Program);
    GL.UseProgram(Program);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now that we have the shader program created and the shaders loaded, we can now render the data. However, we now need to talk about shaders.&lt;/p&gt;

&lt;h3 id=&quot;vertex-shaders-1&quot;&gt;Vertex Shaders&lt;/h3&gt;

&lt;p&gt;Let’s take a look at the shader itself.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #version 400
    layout (location = 0) in vec3 vertex_position;
    layout (location = 1) in vec4 vertex_color;

    uniform mat4 mvp_matrix;

    out vec4 color;

    void main(void)
    {
        color = vertex_color;
        //ref line 124
        gl_Position = mvp_matrix * vec4(vertex_position, 1.0);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;OK, a couple of things to dig into here.  Aside from the GLSL version decorator (the &lt;code class=&quot;highlighter-rouge&quot;&gt;#version 400&lt;/code&gt;), the next two lines define the data that we are expecting to get from the vertex buffer. So the first bit, the &lt;code class=&quot;highlighter-rouge&quot;&gt;layout (location = 0) in vec3 vertex_position;&lt;/code&gt; reads like this&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout(qualifier1, qualifier2 = value, ...) variable definition&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What the layout qualifier does is allow the C# code (CPU code) to not have to directly bind the vertex attribute to the item in the stream (it’s done with a call to &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.GetAttributeLocation()&lt;/code&gt;and &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.BindAttrLocation()&lt;/code&gt;). Otherwise, without those calls, the GLSL compiler assumes that the vertex layout matches what’s defined in the shader - the first attribute in the vertex layout specification is the position, the second attribute in the vertex layout is the color (remember, it’s a 0 based index).&lt;/p&gt;

&lt;p&gt;The next line defines the Model-View-Projection matrix. This is sent in from the CPU side (C# code). The code looks like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Matrix4 ModelViewProjection = ModelViewMatrix *
                                  WorldMatrix *
                                  ProjectionMatrix;

    GL.UseProgram(shaderProgram);
    int mvpLocation = GL.GetUniformLocation(mBasicShader.Program, &quot;mvp_matrix&quot;);
    GL.UniformMatrix4(mvpLocation, false, ref ModelViewProjection);
    GL.UseProgram(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So we use a specifc shader program with &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.UseProgram(ProgramID)&lt;/code&gt; and disable it by calling the same method, but with a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; arguement.&lt;/p&gt;

&lt;p&gt;Sending data to the shader program, in this case the Model-View-projection matrix is done through two functions: the first one to get a variable ID from the program (in this case the &lt;code class=&quot;highlighter-rouge&quot;&gt;mvp_matrix&lt;/code&gt; variable) through &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.GetUniformLocation()&lt;/code&gt;. Then, once we have the variable ID, we can set the data (in this case, it’s a uniform matrix) through &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.UniformMatrix4()&lt;/code&gt;. Whatever we set in this variable is the value the shader will use.&lt;/p&gt;

&lt;p&gt;At this point, it’s all on the shader:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We define an output, that is used in the next shader stage. In this case, the &lt;code class=&quot;highlighter-rouge&quot;&gt;out vec4 color;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;We define the shader entry point, the &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; in C-language speak.&lt;/li&gt;
  &lt;li&gt;We set the output color that we just defined to the color passed in by the vertex buffer&lt;/li&gt;
  &lt;li&gt;we then modify the vertex postion (&lt;code class=&quot;highlighter-rouge&quot;&gt;vertex_position&lt;/code&gt;) passed in on the vertex buffer why the MVP matrix and assign it to a variable called &lt;code class=&quot;highlighter-rouge&quot;&gt;gl_Position&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Where did that &lt;code class=&quot;highlighter-rouge&quot;&gt;gl_Position&lt;/code&gt; variable come from? It’s actually defined as part of OpenGL’s vertex, tesselation evaluation and geometry languages. It’s part of a global instance of the &lt;code class=&quot;highlighter-rouge&quot;&gt;gl_PerVertex&lt;/code&gt; named block. It is an output that receives the homogeneous vertex position; the position of the vertex in screen space. See &lt;a href=&quot;https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_Position.xhtml&quot;&gt;khronos.org&lt;/a&gt; for a deeper breakdown. In other words, the GLSL vertex shader doesn’t output any data, but it does allow us to populate global data in each shader stage.&lt;/p&gt;

&lt;p&gt;OK. What do I mean by ‘each shader stage’. We’ve danced around this a bit. This shader we’ve just looked at? I’ve repeatedly called it the ‘vertex shader’. That’s arguably the first stage in the shading pipeline. However there’s a lot more to it than that.&lt;/p&gt;

&lt;p&gt;Personally, I love this diagram from (http://antongerdelan.net):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://antongerdelan.net/opengl/images/hwpipe2.png&quot; alt=&quot;OpenGL 4 Hardware Pipeline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In all honesty, Anton’s site does a fantastic job talking about the broad aspects of shaders. I’ll try to do justice and dig a bit deeper into them and how we’re using them.&lt;/p&gt;

&lt;h2 id=&quot;fragmentpixel-shaders&quot;&gt;Fragment/Pixel shaders&lt;/h2&gt;

&lt;p&gt;As we’ve seen in the above diagarm, we’ve only touched on Vertex shaders. There’s one last piece of the puzzle, and that’s Pixel/Fragment shaders. I’ll probably end up slipping and call them Pixel shaders more often than Fragment shaders, but I’m using them interchangibly.&lt;/p&gt;

&lt;p&gt;If you look at our C# code, you’ll notice that we don’t do anything with sending data to Pixel shaders. That’s because all the data we’re sending right now is generated in the Vertex shader. In a later article, I’ll introduce how we would do that.&lt;/p&gt;

&lt;p&gt;So, the entire purpose of a pixel shader is, in all honesty, exactly that - how to shade pixels. Adding a color value to a pixel on the screen.&lt;/p&gt;

&lt;p&gt;From the vertex shader, we saw that we set the color output value to that of the vertex color:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  color = vertex_color;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This color is fed into the pixel shader (interpolated across the triangle).&lt;/p&gt;

&lt;p&gt;In the Pixel shader, we don’t actually do a lot:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #version 400

    layout (location = 0) out vec4 frag_color;

    in vec4 color;

    void main(void)
    {
        frag_color = color;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It’s incredibly simple - we set an output value bound to the pixel. In fragment shaders, you can think of this as the index of the output buffer that we are writing the pixel to. If we don’t define one in out CPU code (C# code), and we weren’t to explicitly add the &lt;code class=&quot;highlighter-rouge&quot;&gt;(location=0)&lt;/code&gt; bit to our shader, if there is only ont &lt;code class=&quot;highlighter-rouge&quot;&gt;out&lt;/code&gt; variable, the compiler will normally generate one for us. But don’t do that.&lt;/p&gt;

&lt;p&gt;Thus, we’re only writing out the interpolated color from the fragment shader.  That’s it. Nothing terribly fancy. In a later lesson, I’ll go over more.&lt;/p&gt;

&lt;p&gt;I think that’s enough for this lesson. It’s been a lot to write, as we’re covering a lot of fundamentals.  The rest of the code is fairly self-explanitory.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;
</description>
				<pubDate>Sat, 11 Feb 2017 00:00:00 -0800</pubDate>
				<link>http://localhost:4000/2017/02/OpenGLShaders</link>
				<guid isPermaLink="true">http://localhost:4000/2017/02/OpenGLShaders</guid>
			</item>
		
			<item>
				<title>An Introduction to OpenGL and the Fixed Function Pipeline in C#</title>
				<description>&lt;h1 id=&quot;opengl---2d-and-legacy-3d-fixed-function-beginnings&quot;&gt;OpenGL - 2D and Legacy 3D (Fixed Function beginnings)&lt;/h1&gt;

&lt;p&gt;Welcome to the first part of 3D programming in C# using OpenGL (and OpenTK by extension).&lt;/p&gt;

&lt;p&gt;In this series I’ll talk a fair bit about some 3D math basics, but the real focus of this article series is to help you build and&lt;br /&gt;
understanding of the underlying tech and process that goes on under the hood to get pixels to the screen.&lt;/p&gt;

&lt;p&gt;The structure of the &lt;code class=&quot;highlighter-rouge&quot;&gt;introductory&lt;/code&gt; project is one source file &lt;code class=&quot;highlighter-rouge&quot;&gt;Program.cs&lt;/code&gt; that you can swap out &lt;code class=&quot;highlighter-rouge&quot;&gt;ExampleNN&lt;/code&gt; classes to see different&lt;br /&gt;
implementations of concepts.&lt;/p&gt;

&lt;h1 id=&quot;opengl-2d&quot;&gt;OpenGL 2D&lt;/h1&gt;

&lt;p&gt;A few things to note about OpenGL.&lt;br /&gt;
+ OpenGL works like a state machine. You set the state of something and it stays set until you change it.&lt;br /&gt;
+ There’s a “Legacy”, fixed function API that doesn’t require shaders. We’ll start there.&lt;br /&gt;
+ There’s a new shader based version.&lt;br /&gt;
+ There’s also a new, Vulkan set of extensions. Vulkan is a ‘new’ way of rendering, much closer to console style development.&lt;/p&gt;

&lt;p&gt;So, where to start? Let’s assume a few things.&lt;br /&gt;
+ You understand some basics regarding 3D spaces.&lt;br /&gt;
+ You have some understanding about texture formats and creating C# applications. + You understand C#, creating applications and windows development.&lt;br /&gt;
+ You may have worked with Maya, 3D Max or another DCC package.&lt;/p&gt;

&lt;p&gt;Let’s put some pixels (in the form of a triangle) onto the screen.&lt;/p&gt;

&lt;p&gt;To do that, we first need to create the rendering device. OpenTK handles the majority of that for us. If you really want to see what goes on&lt;br /&gt;
at the truly lowest level (binding a window to an OpenGL context, preparing the rendering buffers, etc) there are a great number of C++&lt;br /&gt;
tutorials online and this topic is outside of the scope of this series.&lt;/p&gt;

&lt;p&gt;All of the examples that I’ll show are Console applications - they don’t have a typical window that’s generated (like a WPF app). OpenTK&lt;br /&gt;
does all of that for you using a class called &lt;code class=&quot;highlighter-rouge&quot;&gt;GameWindow&lt;/code&gt;. So, I’ve created a base class called &lt;code class=&quot;highlighter-rouge&quot;&gt;ExampleBase&lt;/code&gt; that does the majority of the&lt;br /&gt;
setup for you. It initializes the window (at 1024x768, 32 BPP with a 16 bit Depth/Z buffer).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class ExampleBase : GameWindow
{
    public ExampleBase() : base(1024, 768, new OpenTK.Graphics.GraphicsMode(32, 16, 0, 0))
    { }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Just in case you aren’t aware, let’s do a quick review of some things here.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Once we create a window, the actual drawing area (what’s called the canvas), is where we end up using as the drawable area. That area will have a colour depth, in this case it’s set to 32 bits per pixel (2^32 number of colours can be displayed).&lt;/li&gt;
  &lt;li&gt;Next, we define a Depth, or Z-buffer. This allows us to determine the distance of a pixel from the camera. More on that in a bit.&lt;/li&gt;
  &lt;li&gt;We’ll talk about the other numbers later.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Next, I’ve overloaded the &lt;code class=&quot;highlighter-rouge&quot;&gt;OnLoad&lt;/code&gt; method to update the window title and then do this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.ClearColor(0.0f, 0.0f, 0.0f, 0.0f);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;What this does is set the the colour that we use to clear the screen to a specific RGBA value (in this case, full black). This is part of that whole State Machine setup I mentioned earlier; once this value is set, it stays set until it’s changed.&lt;/p&gt;

&lt;p&gt;As part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;GameWindow&lt;/code&gt; class, there is a method that is called each frame called &lt;code class=&quot;highlighter-rouge&quot;&gt;OnRenderFrame&lt;/code&gt;. I overload this method with a call to my own internal method &lt;code class=&quot;highlighter-rouge&quot;&gt;CustomRenderFrame&lt;/code&gt; where each derived class can do it’s own logic. Here’s the code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected override void OnRenderFrame(FrameEventArgs e)
{
    base.OnRenderFrame(e);

    CustomRenderFrame(e.Time);

    base.SwapBuffers();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Finally, we need some simple keyboard handling. So on the &lt;code class=&quot;highlighter-rouge&quot;&gt;OnUpdateFrame&lt;/code&gt; override, we use the OpenTK library &lt;code class=&quot;highlighter-rouge&quot;&gt;Input&lt;/code&gt; to get the state of the keyboard (or, alternatively, the mouse or joystick) to process input devices. In this case, we’re just checking to see if the escape key has been pressed.&lt;/p&gt;

&lt;p&gt;OK, so that’s a rapid look at the basics. It’s overly simplified, but you can easily research the rest to cover the gaps if need be. You can also ask questions and I can add more detail as need be.&lt;/p&gt;

&lt;h2 id=&quot;lesson-01---example-01-putting-a-pixel-on-the-screen&quot;&gt;Lesson 01 - Example 01: Putting a pixel on the screen.&lt;/h2&gt;

&lt;p&gt;Now that we have the ability to build a window, the drawing area that is made available to us is in a ‘normalized’ view. The coordinate system of the window ranges from (-1,-1) to (1,1) with (0,0) being the the center of the window. We’ll call this the ‘Display Coordinate System’.&lt;/p&gt;

&lt;p&gt;Let’s experiment with that, with &lt;code class=&quot;highlighter-rouge&quot;&gt;Example01&lt;/code&gt;. In this example, we want to draw one triangle onto the screen.  Why a triangle? That’s because outside of lines and points, triangles are the base building blocks of 2D and 3D graphics. OpenGL does define other Primitive types (like quads), but they are collections of triangles.&lt;/p&gt;

&lt;p&gt;In the class &lt;code class=&quot;highlighter-rouge&quot;&gt;Example01&lt;/code&gt; we are going to draw a triangle in the window, using the Display coordinate system. To do this, we’re going to use the OpenGL commands &lt;code class=&quot;highlighter-rouge&quot;&gt;Clear&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Begin&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Color&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Vertex&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First off, every frame we need to clear the screen (and any other buffer used in the rendering process). There’s a couple of buffers that we can clear. We’ve already defined a 32 bit colour buffer (what we render to) as well as the Depth buffer. That’s what the following call does:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next up, we begin the actual definition of the data to be rendered. We do this by first defining the primitive type we want to define. In this case, we want to define a set of triangles, or a single triangle (in this case). We do this like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.Begin(BeginMode.Triangles);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So what we’ve done is define a state for the data that is coming down the pipe next. We continue feeding that data until we tell OpenGL that we’re not sending any more data, with an &lt;code class=&quot;highlighter-rouge&quot;&gt;End&lt;/code&gt; call.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.End()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In between the &lt;code class=&quot;highlighter-rouge&quot;&gt;Begin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;End&lt;/code&gt; calls, that’s when we send the triangular data to OpenGL. This is where the commands &lt;code class=&quot;highlighter-rouge&quot;&gt;Color&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Vertex&lt;/code&gt; come into play. So, if we do the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;necessary,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;place&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;clarity&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;GL.Color3(1.0f,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0.0f,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0.0f);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;GL.Vertex2(0,0);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;GL.Color3(0.0f,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1.0f,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0.0f);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;GL.Vertex2(1,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;GL.Color3(0.0f,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0.0f,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1.0f);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;GL.Vertex2(0,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I think it’s fairly obvious what those commands are doing, but to be safe&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Color3()&lt;/code&gt; defines and RGB colour state that is to be used for every subsequent vertex fed into OpenGL via the &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Vertex2&lt;/code&gt; call.  And thus we end up with the following output.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Example01_01.png&quot; alt=&quot;Example01_01.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;lesson-01---example-02-getting-an-idea-of-sizing&quot;&gt;Lesson 01 - Example 02: Getting an idea of sizing&lt;/h2&gt;

&lt;p&gt;With that simple little example out of the way, let’s continue with something a little more - throwing a couple of triangles on the screen to see the real extents of the Display coordinates. Essentially, the rendering code looks like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

GL.Begin(BeginMode.Triangles);

{ // What happens when you change the vertex positions?
    GL.Color3(1.0f, 0.0f, 0.0f);
    GL.Vertex2(-0.5f, -0.5f);

    GL.Color3(0.0f, 0.0f, 1.0f);
    GL.Vertex2(-0.5f, 0.5f);

    GL.Color3(0.0f, 1.0f, 0.0f);
    GL.Vertex2(0.5f, 0.5f);

    GL.Color3(1.0f, 0.0f, 0.0f);
    GL.Vertex2(0.5f, 0.5f);

    GL.Color3(0.0f, 0.0f, 1.0f);
    GL.Vertex2(0.5f, -0.5f);

    GL.Color3(0.0f, 1.0f, 0.0f);
    GL.Vertex2(-0.5f, -0.5f);
}

GL.End();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From this, we end up with the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Example02_01.png&quot; alt=&quot;Example02_01.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;lesson-01---example-03-blending-triangles&quot;&gt;Lesson 01 - Example 03: Blending triangles&lt;/h2&gt;

&lt;p&gt;Everyone knows what transparency is. Implementing it in OpenGL in the fixed function pipeline is fairly easy.  First off, we need to enable a specific feature in OpenGL - Blend. To do that we call&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.Enable(EnableCap.Blend)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That tells OpenGL to enable Blend mode. Now we need to determine what type of blending we’re going to use. There’s lots of differnt types of blend functions, but for now, let’s start with&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;What does that do? The OpenGL blend function is defined &lt;a href=&quot;https://www.opengl.org/sdk/docs/man/html/glBlendFunc.xhtml&quot;&gt;here&lt;/a&gt;. What it tells us is that the first parameter defines the blend function for the source pixel (the triangle we’re drawing) vs the second parameter (the destination pixel).&lt;/p&gt;

&lt;p&gt;Given the current parameters, the source pixel’s Alpha is used in the alpha test. Then the destination’s alpha value is used (1-alpha). These are essentially scalars that are multiplied against the color values, both in the source and destination pixels and then the results are added together. I’ll leave that as an exercise to the reader to work through the math.&lt;/p&gt;

&lt;h2 id=&quot;lesson-01---example-04-drawing-without-using-the-painters-algorithm&quot;&gt;Lesson 01 - Example 04: Drawing without using the painter’s algorithm&lt;/h2&gt;

&lt;p&gt;If you’ve been plaing around with rendering your own triangles, you may have noticed that we’ve only been using &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector2&lt;/code&gt; functions to draw triangles. We’ve been doing this because we only needed 2 dimensions worth of data. However, what would happen if we used &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3&lt;/code&gt; values? If we go that route, we end up using World Coordinates. From a cartesian standpoint, we end up with the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/OpenGL_CoordinateSystem.png&quot; alt=&quot;OpenGL_CoordinateSystem.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Remember that the camera is looking down the Z axis. This means that from the camera perspective Z increments positively towards the camera and negatively away.&lt;/p&gt;

&lt;p&gt;So, in our next example, we do the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected override void CustomRenderFrame(double delta)
{
    GL.ClearDepth(1);
    GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

    GL.Begin(BeginMode.Triangles);
    {
        GL.Color3(1.0f, 0.0f, 0.0f);
        GL.Vertex3(-0.75f, -0.75f, 0.5f);

        GL.Color3(0.0f, 0.0f, 1.0f);
        GL.Vertex3(-0.75f, 0.75f, 0.5f);

        GL.Color3(0.0f, 1.0f, 0.0f);
        GL.Vertex3(0.75f, 0.75f, 0.5f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(0.0f, 0.0f, 0.75f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(0.0f, 1.0f, 0.75f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(1.0f, 0.0f, 0.75f);
    }
    GL.End();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;First, we clear our depth buffer (it gets cleared to 1). Then we draw two sets of data - one triangle at a Z depth of 0.5f and the other at a depth of 0.75f. And they look like they are displaying correctly (and, of course they are). But what happens if you change the order? Like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.Begin(BeginMode.Triangles);
{
        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(0.0f, 0.0f, 0.75f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(0.0f, 1.0f, 0.75f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(1.0f, 0.0f, 0.75f);

        GL.Color3(1.0f, 0.0f, 0.0f);
        GL.Vertex3(-0.75f, -0.75f, 0.5f);

        GL.Color3(0.0f, 0.0f, 1.0f);
        GL.Vertex3(-0.75f, 0.75f, 0.5f);

        GL.Color3(0.0f, 1.0f, 0.0f);
        GL.Vertex3(0.75f, 0.75f, 0.5f);

}
GL.End();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We end up (hopefully) with different results as before. what we end up seeing is that the order in which we present the data to the renderer matters. This is commonly known as the ‘Painters Algorithm’. We can’t always assume that we can sort the triangles before sending them to OpenGL. So we use the Depth buffer to determine if the pixel to be rendered should be consumed or discarded.  In order to enable that, we need to enable the Depth test. That’s fairly simple to do:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected override void OnLoad(EventArgs e)
{
    base.OnLoad(e);
    GL.Enable(EnableCap.DepthTest);
    GL.DepthFunc(DepthFunction.Lequal);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Adding this code and reverting your original changes should result in the triangles being rendered correctly.&lt;/p&gt;

&lt;p&gt;When we get into more ‘proper’ 3D, we’ll discuss how the depth buffer works in conjunction with the projection matrix.&lt;/p&gt;

&lt;h2 id=&quot;lesson-01---example-05-drawing-using-textures&quot;&gt;Lesson 01 - Example 05: Drawing using textures&lt;/h2&gt;

&lt;p&gt;This will cover a bit more content including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;How to load a texture and OpenGL’s Texture functions&lt;/li&gt;
  &lt;li&gt;Mipmapping&lt;/li&gt;
  &lt;li&gt;UV coordinates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How do we load up a texture to feed into OpenGL? We can use the standard bitmap class to read in the data. The problem is, how do we pull the bits in the bitmap into OpenGL? We can access the bits of a bitmap with the &lt;code class=&quot;highlighter-rouge&quot;&gt;LockBits&lt;/code&gt; method. This gives us a &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapData&lt;/code&gt; that we can use to copy the image data into OpenGL.&lt;/p&gt;

&lt;p&gt;Normally we keep a reference or pointer to reuse later. In OpenGL we use numerical IDs to identify resources. We’ll create a TextureID using the &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.GenTexture()&lt;/code&gt; method. We then use the &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.TexImage2D()&lt;/code&gt; method to copy the image data into the Texture resource.&lt;/p&gt;

&lt;p&gt;The last thing we want to do is set up our texture filtering and generate mipmaps. What are Mipmaps? It’s a way to increase speed when you’re using a textured triangle at a distance.&lt;/p&gt;

&lt;p&gt;Think about it, when you are rending a texture where the pixels of the triangle are smaller than what they would be in the source image, we don’t need all that extra data. So we would want to use a smaller version of the image. Which is what a mipmap functionally is. But not just one image, but a cascading pyramid of scaled textures.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mipmap&quot;&gt;wikipedia&lt;/a&gt; article for more information.&lt;/p&gt;

&lt;p&gt;That’s what my &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadTexture()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadImage()&lt;/code&gt; methods do. Once we have the texture loaded, we generate the mipmaps for that texture with the &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.GenerateMpimaps()&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;The last thing is that I’ve created a &lt;code class=&quot;highlighter-rouge&quot;&gt;ContentPipeline&lt;/code&gt; class that holds a dictionary of strings and IDs. The goal here is to keep from re-creating the same texture resource - we simply key a resource to the filename.&lt;/p&gt;

&lt;p&gt;Finally, when we want to draw a textured polygon we need to initialize OpenGL to use textures. In &lt;code class=&quot;highlighter-rouge&quot;&gt;Example05&lt;/code&gt; I’ve updated the class to enable textures like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected override void OnLoad(EventArgs e)
{
    base.OnLoad(e);

    GL.Enable(EnableCap.Texture2D);

    // Load up any resources we need
    mSampleImageTextureID = ContentPipeline.LoadTexture(&quot;resources/SampleImage01.png&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now that we have a Texture ID in the &lt;code class=&quot;highlighter-rouge&quot;&gt;mSampleImageTextureID&lt;/code&gt; variable, we can use that when rendering our next triangle. In order to render a textured triangle, instead of (or in addition to) using &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Color4()&lt;/code&gt;, we use &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.TexCoord2()&lt;/code&gt; to define the texture coordinate for the vertex.&lt;/p&gt;

&lt;p&gt;So what does that mean, Texture Coordinate lookup? Essentially for every Vertex that we have, we can look up a color value for it in a texture. Much like the colors that you saw in the previous examples, a linear look up is done on that texture as well.&lt;/p&gt;

&lt;p&gt;So, this is the source image:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Example05_01.png&quot; alt=&quot;Example05_01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, when we want to render triangles with a texture, we need to provide a lookup into the image. This is what the UV coordinate are used for. The coordinate set ranged from (0, 0) to (1, 1). That’s the top left of the image and to the bottom right of the image.&lt;/p&gt;

&lt;p&gt;So, if we draw a square (two triangles sharing an edge), like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GL.ClearDepth(1);
GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

GL.BindTexture(TextureTarget.Texture2D, mSampleImageTextureID);

GL.Begin(PrimitiveType.Triangles);
{
    GL.Color4(1.0f, 1.0f, 1.0f, 1.0f);

    GL.TexCoord2(0.0f, 0.0f);
    GL.Vertex2(-0.5f, 0.5f);

    GL.TexCoord2(1.0f, 0.0f);
    GL.Vertex2(0.5f, 0.5f);

    GL.TexCoord2(0.0f, 1.0f);
    GL.Vertex2(-0.5f, -0.5f);

    GL.TexCoord2(1.0f, 0.0f);
    GL.Vertex2(0.5f, 0.5f);

    GL.TexCoord2(1.0f, 1.0f);
    GL.Vertex2(0.5f, -0.5f);

    GL.TexCoord2(0.0f, 1.0f);
    GL.Vertex2(-0.5f, -0.5f);

}
GL.End();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A couple of new commands there. &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.BindTexture&lt;/code&gt; takes the texture we had previously loaded as &lt;code class=&quot;highlighter-rouge&quot;&gt;mSampleImageTextureID&lt;/code&gt;. This preps the OpenGL state machine to use the texture (and does all the underlying texture loading). Now, when we providing a vertex, we must first provide a UV coordinate. Remember, it’s a state machine - so we have to set the UV coordinate first. That’s what the &lt;code class=&quot;highlighter-rouge&quot;&gt;GL_TexCoord2()&lt;/code&gt; method does. The other thing to note is that we also set the vertex color as well - &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Color4(1.0f, 1.0f, 1.0f, 1.0f)&lt;/code&gt;. That’s shared across all the vertices. Again, that comes from it being a state machine. That gives us the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Example05_02.png&quot; alt=&quot;Example05_02.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Please notice that the texture hasn’t maintained the aspect ratio of the source pixels. It’s compressed to fit inside the rectangle.&lt;/p&gt;

&lt;p&gt;Play around with the UV coordinates to see what happens when you change them.&lt;/p&gt;

&lt;h1 id=&quot;opengl-3d&quot;&gt;OpenGL 3D&lt;/h1&gt;

&lt;p&gt;OK, now we migrate away from 2D (although there’s much more that can be covered) and into 3D. It starts getting more complex at this point, so we’ll start with a simpler example (no texturing, just simple triangular objects).&lt;/p&gt;

&lt;p&gt;Remeber from Lesson01 - Example 04, we described the coordinate system OpenGL uses for 3D. So let’s say we want to draw a cube. What does the coordinate set look like? Well, we can draw it out on paper first.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/OpenGL3D_CubePrimitive.jpg&quot; alt=&quot;OpenGL3D_CubePrimitive.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pretty straightforward, nothing crazy complex there. So, how do we do all that crazy 3D stuff?&lt;/p&gt;

&lt;h2 id=&quot;lesson-01---example-06-holy-moley-3d&quot;&gt;Lesson 01 - Example 06: Holy Moley 3D&lt;/h2&gt;

&lt;p&gt;In order to do 3d, I’m going to make a new base class called &lt;code class=&quot;highlighter-rouge&quot;&gt;ExampleBase3D&lt;/code&gt;, derived from &lt;code class=&quot;highlighter-rouge&quot;&gt;ExampleBase&lt;/code&gt;. And now we introduce a few new concepts.&lt;/p&gt;

&lt;h3 id=&quot;face-culling&quot;&gt;Face Culling&lt;/h3&gt;

&lt;p&gt;Face culling is all about performance. Drawing a triangle is expensive. Drawing over the same area on screen is expensive. So if we can reject a triangle from drawing, we can get a fair bit of a performance boost. So, how does culling work? It’s based on the order in which the vertices of a triangle are described when it faces the viewer.  In our previous examples, the position of the viewer is, surprise, surprise, where you sit. Starting with the first vertex of the triangle, the order can either be clockwise or counter-clockwise. OpenGL is smart enough to be able to cull either way. Or not cull at all. So, in our overriden &lt;code class=&quot;highlighter-rouge&quot;&gt;OnLoad()&lt;/code&gt; method we have the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;base.OnLoad(e);

GL.Enable(EnableCap.CullFace);
GL.CullFace(CullFaceMode.Back);
GL.Enable(EnableCap.DepthTest);
GL.Enable(EnableCap.DepthClamp);

GL.DepthMask(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In order:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Enable(EnableCap.CullFace)&lt;/code&gt; enabled triangle culling.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GL.CullFace(CullFaceMode.Back)&lt;/code&gt; enable Back-face culling.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The other bits we’ve already covered in other examples.&lt;/p&gt;

&lt;p&gt;In the next section we need to talk about the transformation pipeline. We’ve already alluded to it in the past (when talking about 2D rendering) but now it’s time to go into more detail. I love this site’s explaination of it:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.songho.ca/opengl/gl_transform.html&quot;&gt;Songho.ca&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Example06_01.png&quot; alt=&quot;TransformPipeline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Looking at the image, we have been dealing with Normalized Device Coordinates &amp;gt; Viewport Transform &amp;gt; Windows Coordinates.&lt;/p&gt;

&lt;p&gt;We’re dealing with a 3D object (a set of triangles) that needs to be projected onto a 2D surface (the monitor). We do that (and a few other things) through the use of a projection matrix.&lt;/p&gt;

&lt;p&gt;What does the projection matrix do? It does a couple of things. First, it defines the aspect ration of the ‘window’ that the 3D objects will be rendered to. Why is that important? Well, assume that we don’t have a square window - that’s very possible. If we don’t into account the non-square-ness of the window, you can end up with stretch or squashed transformed triangles. Additionally, we need to take into account the near and far planes of the rendering ‘Frustum’ - the Frustum is a conical shape, a pyramid, with the top point cut off. Where the top is cut off is your monitor’s screen. The bottom of the pyramid is the furthest that you will want to render. Additionally, you want to track the Field of View (vertical) for rendering. I may go into more detail on this in a later update if need be.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected override void OnResize(EventArgs e)
{
    base.OnResize(e);

    GL.Viewport(0, 0, Width, Height);
    double aspectRatio = Width / (double)Height;
    float fov = 1.00899694f;
    float nearPlane = 1.0f;
    float farPlane = 100.0f;

    Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView(fov, (float)aspectRatio, nearPlane, farPlane);
    GL.MatrixMode(MatrixMode.Projection);
    GL.LoadMatrix(ref perspective);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So what we have now is a matrix that we can pass all vertices throught to project them onto the screen from world space. If a triangle falls partially outside of the frustum, it’s clipped. If the triangle is completely outside of the frustum, it’s rejected.&lt;/p&gt;

&lt;p&gt;Also note that we only update the projection matrix when we resize the window; The projection matrix does not take into account the position of the camera. The reason for that is that the camera doesn’t actually rotate; objects rotate into the camera’s view. More on that later.&lt;/p&gt;

&lt;p&gt;If you look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt; class, you’ll see that it’s fairly straight forward.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The constructor takes an eye point.&lt;/li&gt;
  &lt;li&gt;The Update rotates around the Y axis&lt;/li&gt;
  &lt;li&gt;We feed the rotated eye position into &lt;code class=&quot;highlighter-rouge&quot;&gt;Matrix4.LookAt&lt;/code&gt; to build the modelview matrix. We then feed that into the appropriate matrix slot.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The only other thing to describe is the grid that we draw. This is nothing more than a set of lines, rendered with a bit of antialiasing &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Hint(HintTarget.LineSmoothHint, HintMode.Nicest);&lt;/code&gt; and it’s own modelview matrix &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.PushMatrix();&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Translate(dX - grid_size / 2, 0, dZ - grid_size / 2);&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.PopMatrix();&lt;/code&gt;. As always, with the OpenGL state machine, if we need to bracket each state: &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Enables&lt;/code&gt; must have a matching &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.Disable&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.PushMatrix&lt;/code&gt; must have a corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;GL.PopMatrix&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;That’s about it for this project. I’ll update it as I come across missing bits, clarify more things that I’ve only superficially covered. However, this really was only meant as a refresher in Legacy OpenGL. The next project will go into more ‘modern’ OpenGL (shaders).&lt;/p&gt;

&lt;p&gt;I’ve really glossed over a lot of details in this article (OpenGL matrices, Cameras). Rather than overtly ignore it, I’ve included links to, IMO, some great articles on those topics:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(OpenGL Matrices)[http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/]&lt;/li&gt;
  &lt;li&gt;(Transformations)[https://open.gl/transformations]&lt;/li&gt;
  &lt;li&gt;(OpenGL FAQ)[https://www.opengl.org/archives/resources/faq/technical/transformations.htm]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;## Todo&lt;br /&gt;
  [ ] an example of lighting?&lt;br /&gt;
  [ ] shadows?&lt;/p&gt;
</description>
				<pubDate>Mon, 23 Jan 2017 00:00:00 -0800</pubDate>
				<link>http://localhost:4000/2017/01/OpenGLFixedFunction</link>
				<guid isPermaLink="true">http://localhost:4000/2017/01/OpenGLFixedFunction</guid>
			</item>
		
	</channel>
</rss>
