<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>An Introduction to C# graphics | An Introduction to OpenGL and the Fixed Function Pipeline in C# </title>
  <meta name="theme-color" content="#222222" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/header.js"></script>
  <script src="/js/toc.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/theme.css" rel="stylesheet">
  <link href="/css/syntax.css" rel="stylesheet">
  <link href="/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
</head>

<body>

  

  


 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">An Introduction to C# graphics</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="/">/home</a></li>
          <li><a href="/archive.html">/archive</a></li>
          <li><a href="/tags.html">/tags</a></li>
          <li><a href="/about.html">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>

    <div class="wrapper">
      <div class="content">
        <div class="container container-center">
          <div class="row">
            <div class="col-md-2 hidden-xs">
              <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/2017/03/D3DIntroduction">An Introduction to DirectX 11 3D programming using C#</a></li>
    
    <li><a href="/2017/02/OpenGLShaders">An Introduction to OpenGL and the Shader Language</a></li>
    
    <li><a href="/2017/01/OpenGLFixedFunction">An Introduction to OpenGL and the Fixed Function Pipeline in C#</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Tags</h2>
  <ul class="sideBarTags">
    
    
    <li>
      <a href="/tag/C Sharp" data-toggle="tooltip" data-placement="right" title="1">
        <span>C Sharp</span></a></li>
    
    <li>
      <a href="/tag/C#" data-toggle="tooltip" data-placement="right" title="2">
        <span>C#</span></a></li>
    
    <li>
      <a href="/tag/DirectX 11" data-toggle="tooltip" data-placement="right" title="1">
        <span>DirectX 11</span></a></li>
    
    <li>
      <a href="/tag/Fixed Function Pipeline" data-toggle="tooltip" data-placement="right" title="1">
        <span>Fixed Function Pipeline</span></a></li>
    
    <li>
      <a href="/tag/Fragment Shaders" data-toggle="tooltip" data-placement="right" title="1">
        <span>Fragment Shaders</span></a></li>
    
    <li>
      <a href="/tag/OpenGL" data-toggle="tooltip" data-placement="right" title="2">
        <span>OpenGL</span></a></li>
    
    <li>
      <a href="/tag/Pixel Shaders" data-toggle="tooltip" data-placement="right" title="1">
        <span>Pixel Shaders</span></a></li>
    
    <li>
      <a href="/tag/Vertex Shaders" data-toggle="tooltip" data-placement="right" title="1">
        <span>Vertex Shaders</span></a></li>
    
  </ul>
</div>

            </div>
            <div class="col-md-10">
              <div class="article">
                <div class="well">
                  <h1><a href="/2017/01/OpenGLFixedFunction">An Introduction to OpenGL and the Fixed Function Pipeline in C#</a></h1>
                  <div class="post-meta">
                    <div class="post-time">
                      <i class="fa fa-calendar"></i>
                      <time>23 Jan 2017</time>
                    </div>
                    <ul>
                      
                        <li><a href="/tag/OpenGL">OpenGL</a></li>
                      
                        <li><a href="/tag/C#">C#</a></li>
                      
                        <li><a href="/tag/Fixed Function Pipeline">Fixed Function Pipeline</a></li>
                      
                    </ul>
                  </div>
                  <div class="post-content">
                    <div id="toc" class="toc"></div>
                    <h1 id="opengl---2d-and-legacy-3d-fixed-function-beginnings">OpenGL - 2D and Legacy 3D (Fixed Function beginnings)</h1>

<p>Welcome to the first part of 3D programming in C# using OpenGL (and OpenTK by extension).</p>

<p>In this series I’ll talk a fair bit about some 3D math basics, but the real focus of this article series is to help you build and<br />
understanding of the underlying tech and process that goes on under the hood to get pixels to the screen.</p>

<p>The structure of the <code class="highlighter-rouge">introductory</code> project is one source file <code class="highlighter-rouge">Program.cs</code> that you can swap out <code class="highlighter-rouge">ExampleNN</code> classes to see different<br />
implementations of concepts.</p>

<h1 id="opengl-2d">OpenGL 2D</h1>

<p>A few things to note about OpenGL.<br />
+ OpenGL works like a state machine. You set the state of something and it stays set until you change it.<br />
+ There’s a “Legacy”, fixed function API that doesn’t require shaders. We’ll start there.<br />
+ There’s a new shader based version.<br />
+ There’s also a new, Vulkan set of extensions. Vulkan is a ‘new’ way of rendering, much closer to console style development.</p>

<p>So, where to start? Let’s assume a few things.<br />
+ You understand some basics regarding 3D spaces.<br />
+ You have some understanding about texture formats and creating C# applications. + You understand C#, creating applications and windows development.<br />
+ You may have worked with Maya, 3D Max or another DCC package.</p>

<p>Let’s put some pixels (in the form of a triangle) onto the screen.</p>

<p>To do that, we first need to create the rendering device. OpenTK handles the majority of that for us. If you really want to see what goes on<br />
at the truly lowest level (binding a window to an OpenGL context, preparing the rendering buffers, etc) there are a great number of C++<br />
tutorials online and this topic is outside of the scope of this series.</p>

<p>All of the examples that I’ll show are Console applications - they don’t have a typical window that’s generated (like a WPF app). OpenTK<br />
does all of that for you using a class called <code class="highlighter-rouge">GameWindow</code>. So, I’ve created a base class called <code class="highlighter-rouge">ExampleBase</code> that does the majority of the<br />
setup for you. It initializes the window (at 1024x768, 32 BPP with a 16 bit Depth/Z buffer).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>abstract class ExampleBase : GameWindow
{
    public ExampleBase() : base(1024, 768, new OpenTK.Graphics.GraphicsMode(32, 16, 0, 0))
    { }
</code></pre>
</div>

<p>Just in case you aren’t aware, let’s do a quick review of some things here.</p>

<ol>
  <li>Once we create a window, the actual drawing area (what’s called the canvas), is where we end up using as the drawable area. That area will have a colour depth, in this case it’s set to 32 bits per pixel (2^32 number of colours can be displayed).</li>
  <li>Next, we define a Depth, or Z-buffer. This allows us to determine the distance of a pixel from the camera. More on that in a bit.</li>
  <li>We’ll talk about the other numbers later.</li>
</ol>

<p>Next, I’ve overloaded the <code class="highlighter-rouge">OnLoad</code> method to update the window title and then do this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.ClearColor(0.0f, 0.0f, 0.0f, 0.0f);
</code></pre>
</div>

<p>What this does is set the the colour that we use to clear the screen to a specific RGBA value (in this case, full black). This is part of that whole State Machine setup I mentioned earlier; once this value is set, it stays set until it’s changed.</p>

<p>As part of the <code class="highlighter-rouge">GameWindow</code> class, there is a method that is called each frame called <code class="highlighter-rouge">OnRenderFrame</code>. I overload this method with a call to my own internal method <code class="highlighter-rouge">CustomRenderFrame</code> where each derived class can do it’s own logic. Here’s the code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>protected override void OnRenderFrame(FrameEventArgs e)
{
    base.OnRenderFrame(e);

    CustomRenderFrame(e.Time);

    base.SwapBuffers();
}
</code></pre>
</div>

<p>Finally, we need some simple keyboard handling. So on the <code class="highlighter-rouge">OnUpdateFrame</code> override, we use the OpenTK library <code class="highlighter-rouge">Input</code> to get the state of the keyboard (or, alternatively, the mouse or joystick) to process input devices. In this case, we’re just checking to see if the escape key has been pressed.</p>

<p>OK, so that’s a rapid look at the basics. It’s overly simplified, but you can easily research the rest to cover the gaps if need be. You can also ask questions and I can add more detail as need be.</p>

<h2 id="lesson-01---example-01-putting-a-pixel-on-the-screen">Lesson 01 - Example 01: Putting a pixel on the screen.</h2>

<p>Now that we have the ability to build a window, the drawing area that is made available to us is in a ‘normalized’ view. The coordinate system of the window ranges from (-1,-1) to (1,1) with (0,0) being the the center of the window. We’ll call this the ‘Display Coordinate System’.</p>

<p>Let’s experiment with that, with <code class="highlighter-rouge">Example01</code>. In this example, we want to draw one triangle onto the screen.  Why a triangle? That’s because outside of lines and points, triangles are the base building blocks of 2D and 3D graphics. OpenGL does define other Primitive types (like quads), but they are collections of triangles.</p>

<p>In the class <code class="highlighter-rouge">Example01</code> we are going to draw a triangle in the window, using the Display coordinate system. To do this, we’re going to use the OpenGL commands <code class="highlighter-rouge">Clear</code>, <code class="highlighter-rouge">Begin</code>, <code class="highlighter-rouge">Color</code> and <code class="highlighter-rouge">Vertex</code>.</p>

<p>First off, every frame we need to clear the screen (and any other buffer used in the rendering process). There’s a couple of buffers that we can clear. We’ve already defined a 32 bit colour buffer (what we render to) as well as the Depth buffer. That’s what the following call does:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
</code></pre>
</div>

<p>Next up, we begin the actual definition of the data to be rendered. We do this by first defining the primitive type we want to define. In this case, we want to define a set of triangles, or a single triangle (in this case). We do this like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.Begin(BeginMode.Triangles);
</code></pre>
</div>

<p>So what we’ve done is define a state for the data that is coming down the pipe next. We continue feeding that data until we tell OpenGL that we’re not sending any more data, with an <code class="highlighter-rouge">End</code> call.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.End()
</code></pre>
</div>

<p>In between the <code class="highlighter-rouge">Begin</code> and <code class="highlighter-rouge">End</code> calls, that’s when we send the triangular data to OpenGL. This is where the commands <code class="highlighter-rouge">Color</code> and <code class="highlighter-rouge">Vertex</code> come into play. So, if we do the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Not</span><span class="w"> </span><span class="err">necessary,</span><span class="w"> </span><span class="err">just</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">place</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">clarity</span><span class="w">
    </span><span class="err">GL.Color3(1.0f,</span><span class="w"> </span><span class="err">0.0f,</span><span class="w"> </span><span class="err">0.0f);</span><span class="w">
    </span><span class="err">GL.Vertex2(0,0);</span><span class="w">

    </span><span class="err">GL.Color3(0.0f,</span><span class="w"> </span><span class="err">1.0f,</span><span class="w"> </span><span class="err">0.0f);</span><span class="w">
    </span><span class="err">GL.Vertex2(1,</span><span class="w"> </span><span class="err">0);</span><span class="w">

    </span><span class="err">GL.Color3(0.0f,</span><span class="w"> </span><span class="err">0.0f,</span><span class="w"> </span><span class="err">1.0f);</span><span class="w">
    </span><span class="err">GL.Vertex2(0,</span><span class="w"> </span><span class="err">1);</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>I think it’s fairly obvious what those commands are doing, but to be safe</p>

<p><code class="highlighter-rouge">GL.Color3()</code> defines and RGB colour state that is to be used for every subsequent vertex fed into OpenGL via the <code class="highlighter-rouge">GL.Vertex2</code> call.  And thus we end up with the following output.</p>

<p><img src="/Example01_01.png" alt="Example01_01.png" /></p>

<h2 id="lesson-01---example-02-getting-an-idea-of-sizing">Lesson 01 - Example 02: Getting an idea of sizing</h2>

<p>With that simple little example out of the way, let’s continue with something a little more - throwing a couple of triangles on the screen to see the real extents of the Display coordinates. Essentially, the rendering code looks like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

GL.Begin(BeginMode.Triangles);

{ // What happens when you change the vertex positions?
    GL.Color3(1.0f, 0.0f, 0.0f);
    GL.Vertex2(-0.5f, -0.5f);

    GL.Color3(0.0f, 0.0f, 1.0f);
    GL.Vertex2(-0.5f, 0.5f);

    GL.Color3(0.0f, 1.0f, 0.0f);
    GL.Vertex2(0.5f, 0.5f);

    GL.Color3(1.0f, 0.0f, 0.0f);
    GL.Vertex2(0.5f, 0.5f);

    GL.Color3(0.0f, 0.0f, 1.0f);
    GL.Vertex2(0.5f, -0.5f);

    GL.Color3(0.0f, 1.0f, 0.0f);
    GL.Vertex2(-0.5f, -0.5f);
}

GL.End();
</code></pre>
</div>

<p>From this, we end up with the following:</p>

<p><img src="/Example02_01.png" alt="Example02_01.png" /></p>

<h2 id="lesson-01---example-03-blending-triangles">Lesson 01 - Example 03: Blending triangles</h2>

<p>Everyone knows what transparency is. Implementing it in OpenGL in the fixed function pipeline is fairly easy.  First off, we need to enable a specific feature in OpenGL - Blend. To do that we call</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.Enable(EnableCap.Blend)
</code></pre>
</div>

<p>That tells OpenGL to enable Blend mode. Now we need to determine what type of blending we’re going to use. There’s lots of differnt types of blend functions, but for now, let’s start with</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
</code></pre>
</div>

<p>What does that do? The OpenGL blend function is defined <a href="https://www.opengl.org/sdk/docs/man/html/glBlendFunc.xhtml">here</a>. What it tells us is that the first parameter defines the blend function for the source pixel (the triangle we’re drawing) vs the second parameter (the destination pixel).</p>

<p>Given the current parameters, the source pixel’s Alpha is used in the alpha test. Then the destination’s alpha value is used (1-alpha). These are essentially scalars that are multiplied against the color values, both in the source and destination pixels and then the results are added together. I’ll leave that as an exercise to the reader to work through the math.</p>

<h2 id="lesson-01---example-04-drawing-without-using-the-painters-algorithm">Lesson 01 - Example 04: Drawing without using the painter’s algorithm</h2>

<p>If you’ve been plaing around with rendering your own triangles, you may have noticed that we’ve only been using <code class="highlighter-rouge">Vector2</code> functions to draw triangles. We’ve been doing this because we only needed 2 dimensions worth of data. However, what would happen if we used <code class="highlighter-rouge">Vector3</code> values? If we go that route, we end up using World Coordinates. From a cartesian standpoint, we end up with the following:</p>

<p><img src="/OpenGL_CoordinateSystem.png" alt="OpenGL_CoordinateSystem.png" /></p>

<p>Remember that the camera is looking down the Z axis. This means that from the camera perspective Z increments positively towards the camera and negatively away.</p>

<p>So, in our next example, we do the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>protected override void CustomRenderFrame(double delta)
{
    GL.ClearDepth(1);
    GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

    GL.Begin(BeginMode.Triangles);
    {
        GL.Color3(1.0f, 0.0f, 0.0f);
        GL.Vertex3(-0.75f, -0.75f, 0.5f);

        GL.Color3(0.0f, 0.0f, 1.0f);
        GL.Vertex3(-0.75f, 0.75f, 0.5f);

        GL.Color3(0.0f, 1.0f, 0.0f);
        GL.Vertex3(0.75f, 0.75f, 0.5f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(0.0f, 0.0f, 0.75f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(0.0f, 1.0f, 0.75f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(1.0f, 0.0f, 0.75f);
    }
    GL.End();

}
</code></pre>
</div>

<p>First, we clear our depth buffer (it gets cleared to 1). Then we draw two sets of data - one triangle at a Z depth of 0.5f and the other at a depth of 0.75f. And they look like they are displaying correctly (and, of course they are). But what happens if you change the order? Like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.Begin(BeginMode.Triangles);
{
        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(0.0f, 0.0f, 0.75f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(0.0f, 1.0f, 0.75f);

        GL.Color3(1.0f, 1.0f, 1.0f);
        GL.Vertex3(1.0f, 0.0f, 0.75f);

        GL.Color3(1.0f, 0.0f, 0.0f);
        GL.Vertex3(-0.75f, -0.75f, 0.5f);

        GL.Color3(0.0f, 0.0f, 1.0f);
        GL.Vertex3(-0.75f, 0.75f, 0.5f);

        GL.Color3(0.0f, 1.0f, 0.0f);
        GL.Vertex3(0.75f, 0.75f, 0.5f);

}
GL.End();
</code></pre>
</div>

<p>We end up (hopefully) with different results as before. what we end up seeing is that the order in which we present the data to the renderer matters. This is commonly known as the ‘Painters Algorithm’. We can’t always assume that we can sort the triangles before sending them to OpenGL. So we use the Depth buffer to determine if the pixel to be rendered should be consumed or discarded.  In order to enable that, we need to enable the Depth test. That’s fairly simple to do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>protected override void OnLoad(EventArgs e)
{
    base.OnLoad(e);
    GL.Enable(EnableCap.DepthTest);
    GL.DepthFunc(DepthFunction.Lequal);
}
</code></pre>
</div>

<p>Adding this code and reverting your original changes should result in the triangles being rendered correctly.</p>

<p>When we get into more ‘proper’ 3D, we’ll discuss how the depth buffer works in conjunction with the projection matrix.</p>

<h2 id="lesson-01---example-05-drawing-using-textures">Lesson 01 - Example 05: Drawing using textures</h2>

<p>This will cover a bit more content including:</p>

<ul>
  <li>How to load a texture and OpenGL’s Texture functions</li>
  <li>Mipmapping</li>
  <li>UV coordinates</li>
</ul>

<p>How do we load up a texture to feed into OpenGL? We can use the standard bitmap class to read in the data. The problem is, how do we pull the bits in the bitmap into OpenGL? We can access the bits of a bitmap with the <code class="highlighter-rouge">LockBits</code> method. This gives us a <code class="highlighter-rouge">BitmapData</code> that we can use to copy the image data into OpenGL.</p>

<p>Normally we keep a reference or pointer to reuse later. In OpenGL we use numerical IDs to identify resources. We’ll create a TextureID using the <code class="highlighter-rouge">GL.GenTexture()</code> method. We then use the <code class="highlighter-rouge">GL.TexImage2D()</code> method to copy the image data into the Texture resource.</p>

<p>The last thing we want to do is set up our texture filtering and generate mipmaps. What are Mipmaps? It’s a way to increase speed when you’re using a textured triangle at a distance.</p>

<p>Think about it, when you are rending a texture where the pixels of the triangle are smaller than what they would be in the source image, we don’t need all that extra data. So we would want to use a smaller version of the image. Which is what a mipmap functionally is. But not just one image, but a cascading pyramid of scaled textures.</p>

<p>See the <a href="https://en.wikipedia.org/wiki/Mipmap">wikipedia</a> article for more information.</p>

<p>That’s what my <code class="highlighter-rouge">LoadTexture()</code> and <code class="highlighter-rouge">LoadImage()</code> methods do. Once we have the texture loaded, we generate the mipmaps for that texture with the <code class="highlighter-rouge">GL.GenerateMpimaps()</code> method.</p>

<p>The last thing is that I’ve created a <code class="highlighter-rouge">ContentPipeline</code> class that holds a dictionary of strings and IDs. The goal here is to keep from re-creating the same texture resource - we simply key a resource to the filename.</p>

<p>Finally, when we want to draw a textured polygon we need to initialize OpenGL to use textures. In <code class="highlighter-rouge">Example05</code> I’ve updated the class to enable textures like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>protected override void OnLoad(EventArgs e)
{
    base.OnLoad(e);

    GL.Enable(EnableCap.Texture2D);

    // Load up any resources we need
    mSampleImageTextureID = ContentPipeline.LoadTexture("resources/SampleImage01.png");
}
</code></pre>
</div>

<p>Now that we have a Texture ID in the <code class="highlighter-rouge">mSampleImageTextureID</code> variable, we can use that when rendering our next triangle. In order to render a textured triangle, instead of (or in addition to) using <code class="highlighter-rouge">GL.Color4()</code>, we use <code class="highlighter-rouge">GL.TexCoord2()</code> to define the texture coordinate for the vertex.</p>

<p>So what does that mean, Texture Coordinate lookup? Essentially for every Vertex that we have, we can look up a color value for it in a texture. Much like the colors that you saw in the previous examples, a linear look up is done on that texture as well.</p>

<p>So, this is the source image:</p>

<p><img src="/Example05_01.png" alt="Example05_01.png" /></p>

<p>So, when we want to render triangles with a texture, we need to provide a lookup into the image. This is what the UV coordinate are used for. The coordinate set ranged from (0, 0) to (1, 1). That’s the top left of the image and to the bottom right of the image.</p>

<p>So, if we draw a square (two triangles sharing an edge), like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GL.ClearDepth(1);
GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

GL.BindTexture(TextureTarget.Texture2D, mSampleImageTextureID);

GL.Begin(PrimitiveType.Triangles);
{
    GL.Color4(1.0f, 1.0f, 1.0f, 1.0f);

    GL.TexCoord2(0.0f, 0.0f);
    GL.Vertex2(-0.5f, 0.5f);

    GL.TexCoord2(1.0f, 0.0f);
    GL.Vertex2(0.5f, 0.5f);

    GL.TexCoord2(0.0f, 1.0f);
    GL.Vertex2(-0.5f, -0.5f);

    GL.TexCoord2(1.0f, 0.0f);
    GL.Vertex2(0.5f, 0.5f);

    GL.TexCoord2(1.0f, 1.0f);
    GL.Vertex2(0.5f, -0.5f);

    GL.TexCoord2(0.0f, 1.0f);
    GL.Vertex2(-0.5f, -0.5f);

}
GL.End();
}
</code></pre>
</div>

<p>A couple of new commands there. <code class="highlighter-rouge">GL.BindTexture</code> takes the texture we had previously loaded as <code class="highlighter-rouge">mSampleImageTextureID</code>. This preps the OpenGL state machine to use the texture (and does all the underlying texture loading). Now, when we providing a vertex, we must first provide a UV coordinate. Remember, it’s a state machine - so we have to set the UV coordinate first. That’s what the <code class="highlighter-rouge">GL_TexCoord2()</code> method does. The other thing to note is that we also set the vertex color as well - <code class="highlighter-rouge">GL.Color4(1.0f, 1.0f, 1.0f, 1.0f)</code>. That’s shared across all the vertices. Again, that comes from it being a state machine. That gives us the following:</p>

<p><img src="/Example05_02.png" alt="Example05_02.png" /></p>

<p>Please notice that the texture hasn’t maintained the aspect ratio of the source pixels. It’s compressed to fit inside the rectangle.</p>

<p>Play around with the UV coordinates to see what happens when you change them.</p>

<h1 id="opengl-3d">OpenGL 3D</h1>

<p>OK, now we migrate away from 2D (although there’s much more that can be covered) and into 3D. It starts getting more complex at this point, so we’ll start with a simpler example (no texturing, just simple triangular objects).</p>

<p>Remeber from Lesson01 - Example 04, we described the coordinate system OpenGL uses for 3D. So let’s say we want to draw a cube. What does the coordinate set look like? Well, we can draw it out on paper first.</p>

<p><img src="/OpenGL3D_CubePrimitive.jpg" alt="OpenGL3D_CubePrimitive.jpg" /></p>

<p>Pretty straightforward, nothing crazy complex there. So, how do we do all that crazy 3D stuff?</p>

<h2 id="lesson-01---example-06-holy-moley-3d">Lesson 01 - Example 06: Holy Moley 3D</h2>

<p>In order to do 3d, I’m going to make a new base class called <code class="highlighter-rouge">ExampleBase3D</code>, derived from <code class="highlighter-rouge">ExampleBase</code>. And now we introduce a few new concepts.</p>

<h3 id="face-culling">Face Culling</h3>

<p>Face culling is all about performance. Drawing a triangle is expensive. Drawing over the same area on screen is expensive. So if we can reject a triangle from drawing, we can get a fair bit of a performance boost. So, how does culling work? It’s based on the order in which the vertices of a triangle are described when it faces the viewer.  In our previous examples, the position of the viewer is, surprise, surprise, where you sit. Starting with the first vertex of the triangle, the order can either be clockwise or counter-clockwise. OpenGL is smart enough to be able to cull either way. Or not cull at all. So, in our overriden <code class="highlighter-rouge">OnLoad()</code> method we have the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>base.OnLoad(e);

GL.Enable(EnableCap.CullFace);
GL.CullFace(CullFaceMode.Back);
GL.Enable(EnableCap.DepthTest);
GL.Enable(EnableCap.DepthClamp);

GL.DepthMask(true);
</code></pre>
</div>

<p>In order:</p>

<ul>
  <li><code class="highlighter-rouge">GL.Enable(EnableCap.CullFace)</code> enabled triangle culling.</li>
  <li><code class="highlighter-rouge">GL.CullFace(CullFaceMode.Back)</code> enable Back-face culling.</li>
</ul>

<p>The other bits we’ve already covered in other examples.</p>

<p>In the next section we need to talk about the transformation pipeline. We’ve already alluded to it in the past (when talking about 2D rendering) but now it’s time to go into more detail. I love this site’s explaination of it:</p>

<p><a href="http://www.songho.ca/opengl/gl_transform.html">Songho.ca</a></p>

<p><img src="/Example06_01.png" alt="TransformPipeline" /></p>

<p>Looking at the image, we have been dealing with Normalized Device Coordinates &gt; Viewport Transform &gt; Windows Coordinates.</p>

<p>We’re dealing with a 3D object (a set of triangles) that needs to be projected onto a 2D surface (the monitor). We do that (and a few other things) through the use of a projection matrix.</p>

<p>What does the projection matrix do? It does a couple of things. First, it defines the aspect ration of the ‘window’ that the 3D objects will be rendered to. Why is that important? Well, assume that we don’t have a square window - that’s very possible. If we don’t into account the non-square-ness of the window, you can end up with stretch or squashed transformed triangles. Additionally, we need to take into account the near and far planes of the rendering ‘Frustum’ - the Frustum is a conical shape, a pyramid, with the top point cut off. Where the top is cut off is your monitor’s screen. The bottom of the pyramid is the furthest that you will want to render. Additionally, you want to track the Field of View (vertical) for rendering. I may go into more detail on this in a later update if need be.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>protected override void OnResize(EventArgs e)
{
    base.OnResize(e);

    GL.Viewport(0, 0, Width, Height);
    double aspectRatio = Width / (double)Height;
    float fov = 1.00899694f;
    float nearPlane = 1.0f;
    float farPlane = 100.0f;

    Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView(fov, (float)aspectRatio, nearPlane, farPlane);
    GL.MatrixMode(MatrixMode.Projection);
    GL.LoadMatrix(ref perspective);
}
</code></pre>
</div>

<p>So what we have now is a matrix that we can pass all vertices throught to project them onto the screen from world space. If a triangle falls partially outside of the frustum, it’s clipped. If the triangle is completely outside of the frustum, it’s rejected.</p>

<p>Also note that we only update the projection matrix when we resize the window; The projection matrix does not take into account the position of the camera. The reason for that is that the camera doesn’t actually rotate; objects rotate into the camera’s view. More on that later.</p>

<p>If you look at the <code class="highlighter-rouge">Camera</code> class, you’ll see that it’s fairly straight forward.</p>

<ul>
  <li>The constructor takes an eye point.</li>
  <li>The Update rotates around the Y axis</li>
  <li>We feed the rotated eye position into <code class="highlighter-rouge">Matrix4.LookAt</code> to build the modelview matrix. We then feed that into the appropriate matrix slot.</li>
</ul>

<p>The only other thing to describe is the grid that we draw. This is nothing more than a set of lines, rendered with a bit of antialiasing <code class="highlighter-rouge">GL.Hint(HintTarget.LineSmoothHint, HintMode.Nicest);</code> and it’s own modelview matrix <code class="highlighter-rouge">GL.PushMatrix();</code>, <code class="highlighter-rouge">GL.Translate(dX - grid_size / 2, 0, dZ - grid_size / 2);</code> and <code class="highlighter-rouge">GL.PopMatrix();</code>. As always, with the OpenGL state machine, if we need to bracket each state: <code class="highlighter-rouge">GL.Enables</code> must have a matching <code class="highlighter-rouge">GL.Disable</code>, <code class="highlighter-rouge">GL.PushMatrix</code> must have a corresponding <code class="highlighter-rouge">GL.PopMatrix</code>.</p>

<h2 id="summary">Summary</h2>

<p>That’s about it for this project. I’ll update it as I come across missing bits, clarify more things that I’ve only superficially covered. However, this really was only meant as a refresher in Legacy OpenGL. The next project will go into more ‘modern’ OpenGL (shaders).</p>

<p>I’ve really glossed over a lot of details in this article (OpenGL matrices, Cameras). Rather than overtly ignore it, I’ve included links to, IMO, some great articles on those topics:</p>

<ul>
  <li>(OpenGL Matrices)[http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/]</li>
  <li>(Transformations)[https://open.gl/transformations]</li>
  <li>(OpenGL FAQ)[https://www.opengl.org/archives/resources/faq/technical/transformations.htm]</li>
</ul>

<p>## Todo<br />
  [ ] an example of lighting?<br />
  [ ] shadows?</p>

                    

                  </div>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
        

      </div>
          <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Ash Matheson &copy; 2017</p>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="nuclearfossil on Github" href="https://github.com/nuclearfossil" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title=" on StackOverflow" href="https://stackoverflow.com/users/" target="_blank"><i class="fa fa-stack-overflow fa-2x"></i></a>
    </li>
  

  

  
    <li>
      <a title=" on Instagram" href="https://instagram.com/" target="_blank"><i class="fa fa-instagram fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title=" on Last.fm" href="https://www.lastfm.com/user/" target="_blank"><i class="fa fa-lastfm fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title="feed.xml RSS" href="/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>

    </div>
  </body>
</html>
