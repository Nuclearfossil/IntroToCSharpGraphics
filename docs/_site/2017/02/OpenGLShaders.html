<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>An Introduction to C# graphics | An Introduction to OpenGL and the Shader Language </title>
  <meta name="theme-color" content="#222222" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/header.js"></script>
  <script src="/js/toc.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/theme.css" rel="stylesheet">
  <link href="/css/syntax.css" rel="stylesheet">
  <link href="/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
</head>

<body>

  

  


 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">An Introduction to C# graphics</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="/">/home</a></li>
          <li><a href="/archive.html">/archive</a></li>
          <li><a href="/tags.html">/tags</a></li>
          <li><a href="/about.html">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>

    <div class="wrapper">
      <div class="content">
        <div class="container container-center">
          <div class="row">
            <div class="col-md-2 hidden-xs">
              <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/2017/03/D3DIntroduction">An Introduction to DirectX 11 3D programming using C#</a></li>
    
    <li><a href="/2017/02/OpenGLShaders">An Introduction to OpenGL and the Shader Language</a></li>
    
    <li><a href="/2017/01/OpenGLFixedFunction">An Introduction to OpenGL and the Fixed Function Pipeline in C#</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Tags</h2>
  <ul class="sideBarTags">
    
    
    <li>
      <a href="/tag/C Sharp" data-toggle="tooltip" data-placement="right" title="1">
        <span>C Sharp</span></a></li>
    
    <li>
      <a href="/tag/C#" data-toggle="tooltip" data-placement="right" title="2">
        <span>C#</span></a></li>
    
    <li>
      <a href="/tag/DirectX 11" data-toggle="tooltip" data-placement="right" title="1">
        <span>DirectX 11</span></a></li>
    
    <li>
      <a href="/tag/Fixed Function Pipeline" data-toggle="tooltip" data-placement="right" title="1">
        <span>Fixed Function Pipeline</span></a></li>
    
    <li>
      <a href="/tag/Fragment Shaders" data-toggle="tooltip" data-placement="right" title="1">
        <span>Fragment Shaders</span></a></li>
    
    <li>
      <a href="/tag/OpenGL" data-toggle="tooltip" data-placement="right" title="2">
        <span>OpenGL</span></a></li>
    
    <li>
      <a href="/tag/Pixel Shaders" data-toggle="tooltip" data-placement="right" title="1">
        <span>Pixel Shaders</span></a></li>
    
    <li>
      <a href="/tag/Vertex Shaders" data-toggle="tooltip" data-placement="right" title="1">
        <span>Vertex Shaders</span></a></li>
    
  </ul>
</div>

            </div>
            <div class="col-md-10">
              <div class="article">
                <div class="well">
                  <h1><a href="/2017/02/OpenGLShaders">An Introduction to OpenGL and the Shader Language</a></h1>
                  <div class="post-meta">
                    <div class="post-time">
                      <i class="fa fa-calendar"></i>
                      <time>11 Feb 2017</time>
                    </div>
                    <ul>
                      
                        <li><a href="/tag/OpenGL">OpenGL</a></li>
                      
                        <li><a href="/tag/C#">C#</a></li>
                      
                        <li><a href="/tag/Fragment Shaders">Fragment Shaders</a></li>
                      
                    </ul>
                  </div>
                  <div class="post-content">
                    <div id="toc" class="toc"></div>
                    <h1 id="opengl---an-introduction-to-a-more-modern-approach">OpenGL - An introduction to a more modern approach</h1>

<p>In the previous section, we discussed the legacy OpenGL programming model (more commonly refered to as the ‘Fixed Function Pipeline’). In this next section, we’re going to investigate a more modern approach, that utilizes shaders, Vertex buffers, Index buffers and how to send data to shaders from your program.</p>

<h2 id="to-start---a-more-proper-framework">To start - a more proper framework</h2>

<p>In the Introduction project, a lot of things were put together hapdash. I’ve corrected that in the <code class="highlighter-rouge">ShaderIntroduction</code> project:</p>

<p><img src="/InitialClassLayout.png" alt="Initial Class Layout" /></p>

<p>A fair bit has changed with this codebase. I’ve been a bit more regimented in how these classes were defined. They’re also a bit more generalized and properly reusable. Some things to note:</p>

<ol>
  <li>The <code class="highlighter-rouge">ExampleBase</code> class Contains a <code class="highlighter-rouge">Camera</code> by default. It is never Updated (I may change this) so it is up to the derived class to update the camera.</li>
  <li>The <code class="highlighter-rouge">Camera</code> class is a fairly rough FPS-style camera. I will be cleaning this up as we go. However, the <code class="highlighter-rouge">Camera</code> class also maintains the Projection matrix, as well as the View matrix. Traditionally, cameras maintain that information.</li>
  <li><code class="highlighter-rouge">TextureManager</code> is extracted into it’s own class. This will not be used in this lesson (currently), but is going to be used in later lessons.</li>
  <li>The same goes for the <code class="highlighter-rouge">RenderGrid</code> class.</li>
</ol>

<p>In our previous codebase, we were using a more ‘legacy’ based version of OpenGL; this is the fixed function version of OpenGL that does not support shaders.  In this example, we’re going to start talking about using proper shaders. We’re not going to touch on Texturing in this introduction. What we are going to cover, however consists of:</p>

<ol>
  <li>Vertex and Index buffers.</li>
  <li>Setting up data.</li>
  <li>Setting up and creating simple shaders.</li>
  <li>Sending data to shaders.</li>
  <li>Rendering.</li>
</ol>

<p>This is a surprising amount of material to cover and our once-simple applications from the first lesson are going to become significantly more complex.</p>

<h2 id="what-is-a-vertex-buffer">What is a Vertex buffer?</h2>

<p>In our Legacy pipeline (from lesson01), we defined geometry data through using a set of OpenGL state calls to</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    GL.Begin(primitve)
       GL.Color()
       GL.VertexN()
    GL.End()
</code></pre>
</div>

<p>This if far from optimal, considering that for a large amount of data, it never changes. So we can defien a ‘buffer’ of data - in this case a buffer of Vertex data. That goes into what OpenGL calls a <code class="highlighter-rouge">Vertex Buffer Object</code> or <code class="highlighter-rouge">VBO</code>.  Wikipedia defines a VBO as</p>

<blockquote>
  <p>A Vertex Buffer Object (VBO) is an OpenGL feature that provides methods for uploading vertex data (position, normal vector, color, etc.) to the video device for non-immediate-mode rendering. VBOs offer substantial performance gains over immediate mode rendering primarily because the data resides in the video device memory rather than the system memory and so it can be rendered directly by the video device. These are equivalent to vertex buffers in Direct3D.</p>
</blockquote>

<p>However, in modern OpenGL, it is just a <em>buffer</em> of data. It has no inherent structure as far as OpenGL is concerned; you can put whatever the heck you want into it. It is up to a shader program to evaluate the contents of that buffer.</p>

<p>If there is no inherent structure to the data, then how does it work? Let’s walk through a simple example (which is what we use in the current codebase). Let’s assume that right now the only data we want to work with is triangle data. A triangle consists of three vertices: X, Y and Z. We also want to colourized the triangle, so each vertex will have a color component (R, G, B, A). So for each vertex element, we are going to have something that looks like this:</p>

<p><img src="/VBOIntrospection01.png" alt="VBO layout" /></p>

<p>What we’re saying here is that we’re using 12 bytes (3 floats @ 4 bytes/float) to define the positional data of a vertex and 16 bytes (4 floats @ 4 bytes/float) for the color component. This results in a total of 28 bytes for the total data per vertex. This is called the <code class="highlighter-rouge">Stride</code> of the vertex data. What we have done here is created an <code class="highlighter-rouge">interleaved</code> data format. We end up with data that looks like this:</p>

<blockquote>
  <p>[V][C][V][C][V][C][V][C] …</p>
</blockquote>

<p>The stride defines how far we have to jump to get to the next block of data (eg: once we’ve read the first vertex, to get at the next vertex, we have to jump N bytes to read the next vertex … if we skip the color data).</p>

<p>We can also store the vertex attribute data in ‘blocks’, and thus not interleaving the data. Like so:</p>

<blockquote>
  <p>[VVVV…][CCC…]</p>
</blockquote>

<p>Using an interleaved format is probably the most performant, but there are always exceptions to the rule.  So why is it the most performant overall?  From Wikipedia:</p>

<blockquote>
  <p>Interleaved data formats cause less GPU cache pressure, because the vertex coordinate and attributes of a single vertex aren’t scattered all over in memory. They fit consecutively into few cache lines, whereas scattered attributes could cause more cache updates and therefore evictions. The worst case scenario could be one (attribute) element per cache line at a time because of distant memory locations, while vertices get pulled in a non-deterministic/non-contiguous manner, where possibly no prediction and prefetching kicks in. GPUs are very similar to CPUs in this matter.</p>
</blockquote>

<p>It’s also not just VBOs that you’re interested in. You will also want to create an Index Buffer (OpenGL calls these Element Buffer Object or EBOs).  So, what is an EBO? What do we need these for?  Let’s do a simple example to illustrate:</p>

<p><img src="/EBOIntrospection01.png" alt="EBO layout" /></p>

<p>So, what we’ve done is essentially reduce the amount of data that we need to represent a mesh.  If we store the data as pure triangles, with duplication, we end up with <code class="highlighter-rouge">2 Triangles x 3 vertices x 3 floats(x,y,z) x 4 bytes/vertex</code> (no color information in this case) - 72 bytes (168 bytes if we include color). However, using an index buffer, we reduce that to <code class="highlighter-rouge">4 vertices x 3 floats x 4 bytes/vertex</code> - 48 bytes. Adding the index buffer into the mix is <code class="highlighter-rouge">6 indices x 4 bytes</code> - 24 bytes. But that’s assuming 4 bytes/index. Which we really, REALLY don’t need to use. Remember, a <code class="highlighter-rouge">uint</code> gives us a grand total of 4,294,967,295 / 3 (1,431,655,765 triangles). I fear the day we need almost 1.5 billion triangles for games. So we could use half that (a <code class="highlighter-rouge">ushort</code> for instance) to get 65,000 triangles.</p>

<p>However, just in case you think it isn’t that much of a saving. Let’s assume you have a 50,000 triangle mesh. And you have the standard 28 byes/vertex.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    50000 x 3 x 28 = 4,200,000 bytes
</code></pre>
</div>

<p>It’s really hard to say what kind of loss we’d get because it really depends on the mesh geometry, but let’s assume a fully connected mesh where each triangle adds only one additional vertex.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>   ( 50000 + 3 ) * 28 = 1,400,084
   50000 * 3 indices * 2 bytes/index = 300,000
   Total: 1,700,084
</code></pre>
</div>

<p>The less data we need to transfer, the better.  The math may be off, but you can see a couple of additional improvements here as well - we don’t have to duplicate vertices! Instead of an additional 3 floats to represent 1 vertex, we simply add 1 uint to point the an existing vertex in the VBO.</p>

<p>How do you go about creating a <code class="highlighter-rouge">VBO</code>? I’ve encapsulated the core functionality of a VBO in the <code class="highlighter-rouge">VertexBuffer</code> class. The process can be broken down into the following:</p>

<ol>
  <li>Determine the layout of your vertex data. In this case, I’ve already done that.</li>
  <li>Create a data store to transiently hold the data. This is the data your application will track. You’ll also promote this to OpenGL. In the case of our example, we create a <code class="highlighter-rouge">float</code> array that can hold all the data. If your data is not of a consistent data type (ie: you may use a mix of doubles, floats, even ints), you may want to use a struct array instead.</li>
  <li>Create a data store for your EBO.</li>
  <li>You’ll need to have OpenGL create a VBO and EBO buffer for you. Like all buffers in OpenGL, a buffer is represented by an integer value. That ID is written into <code class="highlighter-rouge">mVertexBufferObjectID</code>.</li>
  <li>Populate the VBO and EBO with data.</li>
  <li>Do Render Stuff (Purposely left high level at this point).</li>
</ol>

<h2 id="generating-vbos-and-ebos">Generating VBOs and EBOs</h2>

<p>First off, we need a place to store the data. in <code class="highlighter-rouge">VertexBuffer</code>, we have two members:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    protected float[] mVertexData;
    protected uint[] mIndexData;
</code></pre>
</div>

<p>This is just a way to temporarily hold the data until we can push it up to the graphics card. Populating this array is nothing fancy - check out <code class="highlighter-rouge">AddTriangle</code>, <code class="highlighter-rouge">AddVertex</code> and <code class="highlighter-rouge">AddIndex</code>.</p>

<p>So, to create a VBO and EBO:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    GL.GenBuffers( numBuffersToGenerate, buffersGenerated)
</code></pre>
</div>

<p>But all that does is create a buffer. Now that we have a buffer, we can start working with the data. Remember, OpenGL still works like a state machine, even though it’s ‘Modern’ OpenGL. Now that we have a buffer ID (the Buffer ID is called a <code class="highlighter-rouge">buffer object name</code>), we can start working with it.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    GL.BindBuffer(bufferTargetType, bufferName)
    GL.BufferData(bufferTargetType, size, data, usage)
    GL.BindBuffer(bufferTargetType, bufferName)
</code></pre>
</div>

<p>What do we have now? If done right, we have a buffer for Vertex data and a buffer for index data.</p>

<p>How do we render this? That’s where shaders come in.</p>

<h2 id="vertex-shaders">Vertex Shaders</h2>

<p>I’m going to start off with the technical side of loading up a shader first. After that, more details on the shaders themselves and how we end up getting data into the shaders.</p>

<p>First off, we need some way of creating shaders. Instead of hard-coding it, we’re going to load it from a text file. It’s part of the project, so it gets copied into the output folder.</p>

<p>Loading the shaders is fairly straightforward, we use the <code class="highlighter-rouge">File.ReadAllText()</code> function to pull in all the text from the shader.</p>

<p>Now that we have the shader text, we need to compile the shader. Just like the VBOs and EBOs, we need to create a Shader Named object.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    VertexShaderID = GL.CreateShader(ShaderType.VertexShader);
    FragmentShaderID = GL.CreateShader(ShaderType.FragmentShader);
</code></pre>
</div>

<p>Now we have shader ID to work with. It’s time to compile the shader:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>   GL.ShaderSource(VertexShaderID, VertexShaderSource);
   GL.CompileShader(VertexShaderID);
   GL.GetShaderInfoLog(VertexShaderID, out info);
   GL.GetShader(VertexShaderID, ShaderParameter.CompileStatus, out statusCode);

   if (statusCode != 1)
   {
      Console.Write(info);
      throw new ApplicationException(info);
   }
</code></pre>
</div>

<p>We have to compile two shaders, one for the vertex shader and one for the fragment shader. The shaders, working together constitutes a <code class="highlighter-rouge">Program</code>. So we need to create a program and attach shaders to it:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    Program = GL.CreateProgram();
    GL.AttachShader(Program, FragmentShaderID);
    GL.AttachShader(Program, VertexShaderID);

    GL.LinkProgram(Program);
    GL.UseProgram(Program);
</code></pre>
</div>

<p>Now that we have the shader program created and the shaders loaded, we can now render the data. However, we now need to talk about shaders.</p>

<h3 id="vertex-shaders-1">Vertex Shaders</h3>

<p>Let’s take a look at the shader itself.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    #version 400
    layout (location = 0) in vec3 vertex_position;
    layout (location = 1) in vec4 vertex_color;

    uniform mat4 mvp_matrix;

    out vec4 color;

    void main(void)
    {
        color = vertex_color;
        //ref line 124
        gl_Position = mvp_matrix * vec4(vertex_position, 1.0);
    }
</code></pre>
</div>

<p>OK, a couple of things to dig into here.  Aside from the GLSL version decorator (the <code class="highlighter-rouge">#version 400</code>), the next two lines define the data that we are expecting to get from the vertex buffer. So the first bit, the <code class="highlighter-rouge">layout (location = 0) in vec3 vertex_position;</code> reads like this</p>

<blockquote>
  <p><code class="highlighter-rouge">layout(qualifier1, qualifier2 = value, ...) variable definition</code></p>
</blockquote>

<p>What the layout qualifier does is allow the C# code (CPU code) to not have to directly bind the vertex attribute to the item in the stream (it’s done with a call to <code class="highlighter-rouge">GL.GetAttributeLocation()</code>and <code class="highlighter-rouge">GL.BindAttrLocation()</code>). Otherwise, without those calls, the GLSL compiler assumes that the vertex layout matches what’s defined in the shader - the first attribute in the vertex layout specification is the position, the second attribute in the vertex layout is the color (remember, it’s a 0 based index).</p>

<p>The next line defines the Model-View-Projection matrix. This is sent in from the CPU side (C# code). The code looks like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    Matrix4 ModelViewProjection = ModelViewMatrix *
                                  WorldMatrix *
                                  ProjectionMatrix;

    GL.UseProgram(shaderProgram);
    int mvpLocation = GL.GetUniformLocation(mBasicShader.Program, "mvp_matrix");
    GL.UniformMatrix4(mvpLocation, false, ref ModelViewProjection);
    GL.UseProgram(0);
</code></pre>
</div>

<p>So we use a specifc shader program with <code class="highlighter-rouge">GL.UseProgram(ProgramID)</code> and disable it by calling the same method, but with a <code class="highlighter-rouge">0</code> arguement.</p>

<p>Sending data to the shader program, in this case the Model-View-projection matrix is done through two functions: the first one to get a variable ID from the program (in this case the <code class="highlighter-rouge">mvp_matrix</code> variable) through <code class="highlighter-rouge">GL.GetUniformLocation()</code>. Then, once we have the variable ID, we can set the data (in this case, it’s a uniform matrix) through <code class="highlighter-rouge">GL.UniformMatrix4()</code>. Whatever we set in this variable is the value the shader will use.</p>

<p>At this point, it’s all on the shader:</p>

<ul>
  <li>We define an output, that is used in the next shader stage. In this case, the <code class="highlighter-rouge">out vec4 color;</code></li>
  <li>We define the shader entry point, the <code class="highlighter-rouge">main</code> in C-language speak.</li>
  <li>We set the output color that we just defined to the color passed in by the vertex buffer</li>
  <li>we then modify the vertex postion (<code class="highlighter-rouge">vertex_position</code>) passed in on the vertex buffer why the MVP matrix and assign it to a variable called <code class="highlighter-rouge">gl_Position</code>.</li>
</ul>

<p>Where did that <code class="highlighter-rouge">gl_Position</code> variable come from? It’s actually defined as part of OpenGL’s vertex, tesselation evaluation and geometry languages. It’s part of a global instance of the <code class="highlighter-rouge">gl_PerVertex</code> named block. It is an output that receives the homogeneous vertex position; the position of the vertex in screen space. See <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_Position.xhtml">khronos.org</a> for a deeper breakdown. In other words, the GLSL vertex shader doesn’t output any data, but it does allow us to populate global data in each shader stage.</p>

<p>OK. What do I mean by ‘each shader stage’. We’ve danced around this a bit. This shader we’ve just looked at? I’ve repeatedly called it the ‘vertex shader’. That’s arguably the first stage in the shading pipeline. However there’s a lot more to it than that.</p>

<p>Personally, I love this diagram from (http://antongerdelan.net):</p>

<p><img src="http://antongerdelan.net/opengl/images/hwpipe2.png" alt="OpenGL 4 Hardware Pipeline" /></p>

<p>In all honesty, Anton’s site does a fantastic job talking about the broad aspects of shaders. I’ll try to do justice and dig a bit deeper into them and how we’re using them.</p>

<h2 id="fragmentpixel-shaders">Fragment/Pixel shaders</h2>

<p>As we’ve seen in the above diagarm, we’ve only touched on Vertex shaders. There’s one last piece of the puzzle, and that’s Pixel/Fragment shaders. I’ll probably end up slipping and call them Pixel shaders more often than Fragment shaders, but I’m using them interchangibly.</p>

<p>If you look at our C# code, you’ll notice that we don’t do anything with sending data to Pixel shaders. That’s because all the data we’re sending right now is generated in the Vertex shader. In a later article, I’ll introduce how we would do that.</p>

<p>So, the entire purpose of a pixel shader is, in all honesty, exactly that - how to shade pixels. Adding a color value to a pixel on the screen.</p>

<p>From the vertex shader, we saw that we set the color output value to that of the vertex color:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  color = vertex_color;
</code></pre>
</div>

<p>This color is fed into the pixel shader (interpolated across the triangle).</p>

<p>In the Pixel shader, we don’t actually do a lot:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    #version 400

    layout (location = 0) out vec4 frag_color;

    in vec4 color;

    void main(void)
    {
        frag_color = color;
    }
</code></pre>
</div>

<p>It’s incredibly simple - we set an output value bound to the pixel. In fragment shaders, you can think of this as the index of the output buffer that we are writing the pixel to. If we don’t define one in out CPU code (C# code), and we weren’t to explicitly add the <code class="highlighter-rouge">(location=0)</code> bit to our shader, if there is only ont <code class="highlighter-rouge">out</code> variable, the compiler will normally generate one for us. But don’t do that.</p>

<p>Thus, we’re only writing out the interpolated color from the fragment shader.  That’s it. Nothing terribly fancy. In a later lesson, I’ll go over more.</p>

<p>I think that’s enough for this lesson. It’s been a lot to write, as we’re covering a lot of fundamentals.  The rest of the code is fairly self-explanitory.</p>

<p>Until next time!</p>

                    

                  </div>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
        

      </div>
          <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Ash Matheson &copy; 2017</p>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="nuclearfossil on Github" href="https://github.com/nuclearfossil" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title=" on StackOverflow" href="https://stackoverflow.com/users/" target="_blank"><i class="fa fa-stack-overflow fa-2x"></i></a>
    </li>
  

  

  
    <li>
      <a title=" on Instagram" href="https://instagram.com/" target="_blank"><i class="fa fa-instagram fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title=" on Last.fm" href="https://www.lastfm.com/user/" target="_blank"><i class="fa fa-lastfm fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title="feed.xml RSS" href="/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>

    </div>
  </body>
</html>
